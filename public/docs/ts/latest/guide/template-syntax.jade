block includes
  include ../_util-fns
  - var _JavaScript = 'JavaScript';
  //- Double underscore means don't escape var, use !{__var}.
  - var __chaining_op = '<code>;</code> or <code>,</code>';
  - var __chaining_op_ko = '<code>;</code> 와 <code>,</code>';
  - var __new_op = '<code>new</code>';
  - var __objectAsMap = 'object';
  - var __objectAsMap_ko = '객체';

:marked
  우리의 Angular 애플리케이션은 Component 클래스 인스턴스(*컴포넌트*)와 사용자가 접하는 템플릿과의 상호작용을 통해 사용자가 보는 것과 할 수 있는 것을 관리합니다.

  Our Angular application manages what the user sees and can do, achieving this through the interaction of a Component class instance (the *component*) and its user-facing template.

  대부분의 사람들은 모델-뷰-컨트롤러 (MVC)나 모델-뷰-뷰모델 (MVVM)의 경험을 통해 컴포넌트/템플릿의 이중성에 익숙합니다. Angular에서는 컴포넌트가 컨트롤러/뷰모델 역할을 하고, 템플릿이 뷰를 표현합니다.

  Many of us are familiar with the component/template duality from our experience with model-view-controller (MVC) or model-view-viewmodel (MVVM). In Angular,  the component plays the part of the controller/viewmodel, and the template represents the view.

  뷰를 위한 템플릿을 작성하기 위해 무엇이 필요한지 알아보겠습니다. 템플릿 구문의 기본 요소는 다음과 같습니다:

  Let’s find out what it takes to write a template for our view. We’ll cover these basic elements of template syntax:

  * [HTML](#html)
  * [HTML](#html)
  * [삽입식(interpolation)](#interpolation)
  * [Interpolation](#interpolation)
  * [템플릿 표현식(expression)](#template-expressions)
  * [Template expressions](#template-expressions)
  * [템플릿 명령문(statement)](#template-statements)
  * [Template statements](#template-statements)
  * [바인딩 문법](#binding-syntax)
  * [Binding syntax](#binding-syntax)
  * [프러퍼티 바인딩](#property-binding)
  * [Property binding](#property-binding)
  * [속성, 클래스, 스타일 바인딩](#other-bindings)
  * [Attribute, class, and style bindings](#other-bindings)
  * [이벤트 바인딩](#event-binding)
  * [Event binding](#event-binding)
  * [양방향 데이터 바인딩](#two-way)
  * [Two-way data binding](#two-way)
  * [`NgModel`을 사용한 양방향 데이터 바인딩](#ngModel)
  * [Two-way data binding with `NgModel`](#ngModel)
  * [내장 지시자](#directives)

    [Built-in directives](#directives)

    * [NgClass](#ngClass)

      [NgClass](#ngClass)

    * [NgStyle](#ngStyle)

      [NgStyle](#ngStyle)

    * [NgIf](#ngIf)

      [NgIf](#ngIf)

    * [NgSwitch](#ngSwitch)

      [NgSwitch](#ngSwitch)

    * [NgFor](#ngFor)

      [NgFor](#ngFor)
  * [* 와 &lt;template>](#star-template)
  * [* and &lt;template>](#star-template)
  * [템플릿 참조 변수](#ref-vars)
  * [Template reference variables](#ref-vars)
  * [인풋, 아웃풋 프로퍼티](#inputs-outputs)
  * [Input and output properties](#inputs-outputs)
  * [템플릿 표현식 연산자](#expression-operators)

    [Template expression operators](#expression-operators)

    * [파이프](#pipe)

      [pipe](#pipe)

    * [안전 내비게이션 연산자 (?.)](#safe-navigation-operator)

      [safe navigation operator (?.)](#safe-navigation-operator)

  <live-example></live-example>는 이번 챕터에서 설명하는 코드조각과 구문의 모든 것을 설명하고 있습니다.

  The <live-example></live-example>
  demonstrates all of the syntax and code snippets described in this chapter.

.l-main-section
:marked
  ## HTML
  ## HTML

  HTML은 Angular 템플릿 언어입니다.
  [빠른시작](../quickstart.html) 애플리케이션은 순수 HTML 템플릿을 사용했습니다:

  HTML is the language of the Angular template. 
  The [QuickStart](../quickstart.html) application has a template that is pure HTML:

code-example(language="html" escape="html").
  <h1>Hello Angular</h1>

:marked
  거의 모든 HTML 구문이 유효한 템플릿 구문입니다. `<script>` 엘리먼트는 주요 예외사항입니다; 스크립트 삽입(injection) 공격의 위험을 없애기 위해 금지되어 있습니다. (실제로, `<script>`는 그저 무시됩니다.)

  Almost all HTML syntax is valid template syntax. The `<script>` element is a notable exception; it is forbidden, eliminating the risk of script injection attacks. (In practice, `<script>` is simply ignored.)

  일부 합법적인 HTML은 템플릿에서 별 의미가 없습니다. `<html>`, `<body>`, 그리고 `<base>` 엘리먼트는 우리의 레퍼토리에서 유용한 역할을 못합니다. 그 외 대부분은 사용 가능한 대상입니다.

  Some legal HTML doesn’t make much sense in a template. The `<html>`, `<body>`, and `<base>` elements have no useful role in our repertoire. Pretty much everything else is fair game.

  새로운 엘리먼트와 속성처럼 보이는 컴포넌트와 지시자로 템플릿의 HTML 어휘(vocabulary)를 확장할 수 있습니다. 다음 섹션에서는 데이터 바인딩을 통해 어떻게 동적으로 DOM (Document Object Model) 값을 가져오고 설정하는지 배워보겠습니다.

  We can extend the HTML vocabulary of our templates with components and directives that appear as new elements and attributes. In the following sections we are going to learn how to get and set DOM (Document Object Model) values dynamically through data binding.

  템플릿 HTML이 얼마나 풍부해 질 수 있는지 보기 위해 데이터 바인딩의 첫번째 형식 &mdash; 삽입식 &mdash;을 살펴보겠습니다.

  Let’s turn to the first form of data binding &mdash; interpolation &mdash; to see how much richer template HTML can be.

.l-main-section
:marked
  ## 삽입식
  ## Interpolation
  앞서 우리는 Angular 교육 중에 삽입식의 이중 중괄호, `{{`와 `}}`,를 보았습니다.

  We met the double-curly braces of interpolation, `{{` and `}}`, early in our Angular education.
+makeExample('template-syntax/ts/app/app.component.html', 'first-interpolation')(format=".")
:marked
  삽입식을 사용해 계산된 문자열을 HTML 엘리먼트 태그 사이나 속성 할당 안에 끼워 넣습니다.

  We use interpolation to weave calculated strings into the text between HTML element tags and within attribute assignments.

+makeExample('template-syntax/ts/app/app.component.html', 'title+image')(format=".")
:marked
  중괄호 사이에 들어가는 내용은 종종 컴포넌트 프로퍼티의 이름입니다. Angular는 문자열 값을
  그에 대응하는 컴포넌트 프로퍼티로 교체합니다. 위의 예에서, Angular는 `title`과 `heroImageUrl` 프로퍼티를 평가하고
  "빈 칸을 채웁니다", 첫 번째는 굵은 애플리케이션 제목을, 다음은 히어로 이미지를 표시합니다.

  The material between the braces is often the name of a component property. Angular replaces that name with the
  string value of the corresponding component property. In the example above, Angular evaluates the `title` and `heroImageUrl` properties
  and "fills in the blanks", first displaying a bold application title and then a heroic image.

  보다 일반적으로, 중괄호 사이의 내용은 **템플릿 표현식**으로 Angular가 먼저 **평가**를 하고 **문자열로 변환**하는 것입니다.
  다음 삽입식은 중괄호 안의 두 개의 숫자를 더하여 특징을 설명합니다.

  More generally, the material between the braces is a **template expression** that Angular first **evaluates**
  and then **converts to a string**. The following interpolation illustrates the point by adding the two numbers within braces:
+makeExample('template-syntax/ts/app/app.component.html', 'sum-1')(format=".")
:marked
  표현식은 `getValue()`를 사용한 것처럼, 주인 컴포넌트의 메소드를 호출할 수 있습니다:

  The expression can invoke methods of the host component, as we do here with `getVal()`:
+makeExample('template-syntax/ts/app/app.component.html', 'sum-2')(format=".")
:marked
  Angular는 이중 중괄호의 모든 표현식을 평가하고, 표현식의 결과를 문자열로 변환하고, 이웃 리터럴 문자열에 연결합니다.
  최종적으로, 이 복합 삽입 결과를 **엘리먼트나 지시자 속성**에 할당합니다.

  Angular evaluates all expressions in double curly braces, converts the expression results to strings, and links them with neighboring literal strings. Finally,
  it assigns this composite interpolated result to an **element or directive property**.

  마치 엘리먼트 태그 사이에 결과를 삽입하고 속성에 할당하는 것으로 보입니다.
  그렇게 생각하는 것이 편리하며, 실수로 고통을 겪지 않을 수 있습니다.
  비록 이것이 정확한 사실은 아니지만요. 삽입식은 Angular가
  [프로퍼티 바인딩](#property-binding)으로 변환하는 특별한 구문이며,
  아래에 설명되어 있습니다.

  We appear to be inserting the result between element tags and assigning it to attributes.
  It's convenient to think so, and we rarely suffer for this mistake.
  Though this is not exactly true. Interpolation is a special syntax that Angular converts into a
  [property binding](#property-binding), and is explained below.

  그러나 먼저, 템플릿 표현식과 명령문에 대해 자세히 살펴보겠습니다.

  But first, let's take a closer look at template expressions and statements.

<a id="template-expressions"></a>
.l-main-section
:marked
  ## 템플릿 표현식
  ## Template expressions

  템플릿 **표현식**은 값을 생산합니다.
  Angular는 표현식을 실행하고 바인딩 타겟의 프로퍼티에 할당합니다;
  타겟은 HTML 엘리먼트, 컴포넌트, 또는 지시자일 수 있습니다.

  A template **expression** produces a value.
  Angular executes the expression and assigns it to a property of a binding target;
  the target might be an HTML element, a component, or a directive.

  `{{1 + 1}}`을 썼을 때 템플릿 표현식을 삽입식 중괄호 사이에 놓았습니다.
  [프로퍼티 바인딩](#property-binding) 섹션에서 템플릿 표현식을 다시 볼 것입니다.
  `[프로퍼티]="표현식"` 처럼 `=` 기호의 오른쪽에 따옴표로 묶인 부분입니다.

  We put a template expression within the interpolation braces when we wrote `{{1 + 1}}`.
  We’ll see template expressions again in the [property binding](#property-binding) section,
  appearing in quotes to the right of the `=` symbol as in `[property]="expression"`.

  템플릿 표현식은 #{_JavaScript}처럼 보이는 언어로 작성합니다.
  대부분의 #{_JavaScript} 표현식이 템플릿 표현식에서 유효합니다, 전부는 아니지만요.

  We write template expressions in a language that looks like #{_JavaScript}.
  Many #{_JavaScript} expressions are legal template expressions, but not all.

  다음과 같이 부작용을 가지고 있거나 부작용을 유발하는 #{_JavaScript} 표현식은
  금지됩니다:

  #{_JavaScript} expressions that have or promote side effects are prohibited,
  including:

  * 할당 (`=`, `+=`, `-=`, ...)

  * assignments (`=`, `+=`, `-=`, ...)

  * !{__new_op}

  * !{__new_op}

  * !{__chaining_op_ko}을 사용한 연결 표현식

  * chaining expressions with !{__chaining_op}

  * 증가 연산자와 감소 연산자 (`++` 와 `--`)

  * increment and decrement operators (`++` and `--`)

:marked
  다른 #{_JavaScript} 구문과의 주목할만한 차이점은 다음과 같습니다:
  
  Other notable differences from #{_JavaScript} syntax include:

block notable-differences
  :marked
    * 비트 연산자 `|`와 `&`를 지원하지 않음

    * no support for the bitwise operators `|` and `&`

    * `|`나 `?.` 같은 새로운 [템플릿 표현식 연산자](#expression-operators)

    * new [template expression operators](#expression-operators), such as `|` and `?.`

h3#expression-context 표현식 컨텍스트
h3#expression-context Expression context

block template-expressions-cannot
  :marked
    어쩌면 더욱 놀랍게도, 템플릿 표현식은 전역 네임스페이스 안의 어떤 것도
    참조할 수 없습니다. `window`나 `document` 같은 것을 참조할 수 없습니다.
    `console.log`나 `Math.max` 같은 것을 호출 할 수 없습니다. 표현식 컨텍스트의
    멤버만 참조하도록 제한되어 있습니다.

    Perhaps more surprising, template expressions cannot refer to anything in
    the global namespace. They can’t refer to `window` or `document`. They
    can’t call `console.log` or `Math.max`. They are restricted to referencing
    members of the expression context.

:marked
  *표현식 컨텍스트*는 일반적으로 바인딩 값의 소스가 되는
  **컴포넌트 인스턴스**입니다.

  The *expression context* is typically the **component instance**, which is
  the source of binding values.

  이중 중괄호안에 포함된 *title*을 보면, `{{title}}`,
  `title`이 데이터형(data-bound) 컴포넌트의 프로퍼티임을 알 수 있습니다.
  `[disabled]="isUnchanged"`에서 *isUnchanged*를 보면,
  컴포넌트의 `isUnchanged` 프로퍼티를 참조하는 것을 알 수 있습니다.

  When we see *title* wrapped in double-curly braces, `{{title}}`,
  we know that `title` is a property of the data-bound component.
  When we see *isUnchanged* in `[disabled]="isUnchanged"`,
  we know we are referring to that component's `isUnchanged` property.

  컴포넌트 자체가 보통 표현식의 컨텍스트입니다.
  이 경우 템플릿 표현식은 대게 해당 컴포넌트를 참조합니다.

  The component itself is usually the expression *context*, in which case
  the template expression usually references that component.

  표현식 컨텍스트에 컴포넌트가 아닌 객체를 포함할 수도 있습니다.
  [템플릿 참조 변수](#ref-vars)는 이러한 대체 컨텍스트 객체의 하나입니다.

  The expression context can include objects other than the component.
  A [template reference variable](#ref-vars) is one such alternative context object.

:marked
  <a id="no-side-effects"></a>
  ### 표현식 가이드라인
  ### Expression guidelines

  템플릿 표현식은 애플리케이션을 완성할 수도 깨지게 할 수도 있습니다.
  부디 다음 가이드라인을 따르세요:

  Template expressions can make or break an application.
  Please follow these guidelines:

  * [표시 부작용 제거](#no-visible-side-effects)

  * [No visible side effects](#no-visible-side-effects)

  * [빠른 실행](#quick-execution)

  * [Quick execution](#quick-execution)

  * [단순함](#simplicity)

  * [Simplicity](#simplicity)

  * [멱등성(idempotence)](#idempotence)

  * [Idempotence](#idempotence)

  이 가이드라인의 유일한 예외는 완벽히 이해를 하고 있는 특별한 상황이어야 합니다.

  The only exceptions to these guidelines should be in specific circumstances that you thoroughly understand.

  #### 표시 부작용 제거
  #### No visible side effects

  템플릿 표현식은 타겟 프로퍼티의 값 외에는 어떤 애플리케이션 상태도
  변경해서는 안됩니다.

  A template expression should not change any application state other than the value of the
  target property.

  이것은 Angular의 "단방향성 데이터 흐름" 정책에 중요한 원칙입니다.
  컴포넌트의 값을 읽는 것이 다른 표시 값을 변경할 수 있다는 염려를 하지 않을 수 있어야 합니다.
  뷰는 단일 렌더링 단계를 통틀어 안정되어야 합니다.

  This rule is essential to Angular's "unidirectional data flow" policy.
  We should never worry that reading a component value might change some other displayed value.
  The view should be stable throughout a single rendering pass.

  #### 빠른 실행
  #### Quick execution

  Angular는 우리가 생각하는 것보다 자주 템플릿 표현식을 실행합니다.
  모든 키 입력과 마우스 이동 후에 호출될 수 있습니다.
  표현식은 빨리 끝나야만 합니다. 그렇지 않으면 사용자는 특히 느린 기기에서 지연을 느낄 수 있습니다.
  계산 비용이 비쌀 경우 다른 값에서 계산된 값을 캐시하는 것을 고려해보세요.

  Angular executes template expressions more often than we think.
  They can be called after every keypress or mouse move.
  Expressions should finish quickly or the user experience may drag, especially on slower devices.
  Consider caching values computed from other values when the computation is expensive.

  #### 단순함 
  #### Simplicity

  비록 매우 복잡한 템플릿 표현식을 작성할 수 있지만, 그렇게 하지 않아야만 합니다.

  Although it's possible to write quite complex template expressions, we really shouldn't.

  프로퍼티 이름이나 메소드 호출은 표준을 따라야 합니다.
  때때로 사용하는 불리언 부정 (`!`)은 괜찮습니다.
  한편, 애플리케이션과 비즈니스 로직을 컴포넌트 자체에 한정해야 하고,
  그곳에서 개발 및 테스트를 쉽게 할 수 있어야 합니다.

  A property name or method call should be the norm.
  An occasional Boolean negation (`!`) is OK.
  Otherwise, confine application and business logic to the component itself,
  where it will be easier to develop and test.

  #### 멱등성(idempotence)
  #### Idempotence

  [멱등](https://en.wikipedia.org/wiki/Idempotence) 표현식은 이상적인 것입니다.
  왜냐하면 부작용에서 자유로와 Angular의 변경 탐지 성능을 개선시키기 때문입니다.

  An [idempotent](https://en.wikipedia.org/wiki/Idempotence) expression is ideal because
  it is free of side effects and improves Angular's change detection performance.

  Angular 용어에서 멱등 표현식은 그것에 종속된 값이 변경되지 않는한
  항상 *완전히 똑같은 것*을 반환합니다.

  In Angular terms, an idempotent expression always returns *exactly the same thing* until
  one of its dependent values changes.
:marked
  이벤트 루프의 단일 단계 중에는 종속된 값이 변경되지 않아야 합니다.
  만약 멱등 표현식이 문자열이나 숫자를 반환한다면, 연속으로 두번을 호출할 때
  같은 문자열이나 숫자를 반환합니다. 만약 표현식이 객체를 반환한다면 (배열을 포함해),
  연속으로 두번을 호출할 때 같은 객체 *참조*를 반환합니다.

  Dependent values should not change during a single turn of the event loop.
  If an idempotent expression returns a string or a number, it returns the same string or number
  when called twice in a row. If the expression returns an object (including #{_an} `#{_Array}`),
  it returns the same object *reference* when called twice in a row.

.l-main-section#template-statements
:marked
  ## 템플릿 명령문
  ## Template statements

  템플릿 **명령문**은 엘리먼트, 컴포넌트, 또는 지시자와 같은
  바인딩 타겟에서 발생하는 **이벤트**에 반응합니다. 

  A template **statement** responds to an **event** raised by a binding target
  such as an element, component, or directive.

  [이벤트 바인딩](#event-binding) 섹션에서 템플릿 명령문을 살펴볼 것입니다.
  `(event)="statement"`처럼 `=` 기호의 오른쪽에 따옴표로 묶인 부분입니다.

  We’ll see template statements in the [event binding](#event-binding) section,
  appearing in quotes to the right of the `=` symbol as in `(event)="statement"`.

  템플릿 명령문은 *부작용을 가지고 있습니다*.
  이것을 활용해 사용자 입력으로부터 애플리케이션 상태를 업데이트 합니다.
  그렇지 않으면 이벤트에 응답할 방법이 없습니다.

  A template statement *has a side effect*.
  It's how we update application state from user input.
  There would be no point to responding to an event otherwise.

.l-sub-section
  :marked
    이벤트에 응답하는 것은 Angular의 "단방향성 데이터 흐름"의 또 다른 측면입니다.
    이벤트 루프의 이 단계 중에는 어떤 것이든, 어디서든 자유롭게 변경할 수 있습니다.

    Responding to events is the other side of Angular's "unidirectional data flow".
    We're free to change anything, anywhere, during this turn of the event loop.

:marked
  템플릿 표현식처럼, 템플릿 *명령문*은 #{_JavaScript}처럼 보이는 언어를 사용합니다.
  템플릿 명령문 파서는 템플릿 표현식 파서와 다릅니다.
  특히 기본 할당 (`=`)과 표현식 연결 (!{__chaining_op}을 사용)을 지원합니다.

  Like template expressions, template *statements* use a language that looks like #{_JavaScript}.
  The template statement parser is different than the template expression parser and
  specifically supports both basic assignment (`=`) and chaining expressions 
  (with !{__chaining_op}).

  하지만, 일부 #{_JavaScript} 구문은 허용되지 않습니다:

  However, certain #{_JavaScript} syntax is not allowed:

  * !{__new_op}

  * !{__new_op}

  * 증가와 감소 연산자, `++` 와 `--`

  * increment and decrement operators, `++` and `--`

  * `+=` 와 `-=` 같은 연산자 할당

  * operator assignment, such as `+=` and `-=`

  * 비트 연산자 `|` 와 `&`

  * the bitwise operators `|` and `&`

  * [템플릿 표현식 연산자](#expression-operators)

  * the [template expression operators](#expression-operators)

:marked
  ### 명령문 컨텍스트
  ### Statement context

  표현식처럼, 명령문은 오직 명령문 컨텍스트 안에 있는 것만 참조할 수 있습니다. —
  명령문 컨텍스트는 전형적으로 이벤트를 바인딩하는 **컴포넌트 인스턴스** 입니다.

  As with expressions, statements can refer only to what's in the statement context — typically the
  **component instance** to which we're binding the event.

block statement-context
  :marked
    템플릿 명령문은 전역 네임스페이스에 있는 어떤 것도
    참조할 수 없습니다. `window`나 `document` 같은 것을 참조할 수 없습니다.
    `console.log`나 `Math.max` 같은 것을 호출 할 수 없습니다.

    Template statements cannot refer to anything in the global namespace. They
    can’t refer to `window` or `document`. They can’t call `console.log` or
    `Math.max`.

:marked
  `(click)="onSave()"`의 *onSave*는 데이터형(data-bound) 컴포넌트 인스턴스의 메소드임이 확실합니다.

  The *onSave* in `(click)="onSave()"` is sure to be a method of the data-bound component instance.

  명령문 컨텍스트는 컴포넌트가 아닌 객체를 포함할 수도 있습니다.
  [템플릿 참조 변수](#ref-vars)는 이러한 대체 컨텍스트 객체의 하나입니다.
  이벤트 바인딩 명령문에서 발생 이벤트의 "메시지"나 "payload"를 나타내는
  예약 기호 `$event`를 자주 볼 수 있습니다.

  The statement context may include an object other than the component.
  A [template reference variable](#ref-vars) is one such alternative context object.
  We'll frequently see the reserved `$event` symbol in event binding statements,
  representing the "message" or "payload" of the raised event.

  ### 명령문 가이드라인
  ### Statement guidelines

  표현식과 마찬가지로, 복잡한 템플릿 명령문을 피하세요.
  메소드 호출이나 간단한 프로퍼티 할당은 표준을 따라야 합니다.

  As with expressions, avoid writing complex template statements.
  A method call or simple property assignment should be the norm.

  이제 우리는 템플릿 표현식과 명령문의 맛을 보았으므로,
  삽입식을 넘어 다양한 데이터 바인딩 구문을 배울 준비가 되었습니다.

  Now that we have a feel for template expressions and statements,
  we’re ready to learn about the varieties of data binding syntax beyond interpolation.

.l-main-section
:marked
  <a id="binding-syntax"></a>
  ## 바인딩 구문: 개요 
  ## Binding syntax: An overview

  데이터 바인딩은 사용자가 보는 것을 애플리케이션 데이터 값으로 조정하기 위한 메커니즘입니다.
  비록 HTML에서 값을 가져오고 보낼 수 있지만,
  만약 이러한 성가신 일을 바인딩 프레임워크에 위임할 수 있다면 애플리케이션을 작성하고, 읽고, 유지 관리하기가 보다 수월해집니다.
  우리는 그저 바인딩할 소스와 타겟 HTML 엘리먼트 사이에 바인딩을 선언하고 프레임워크가 일을 하게 하면 됩니다.

  Data binding is a mechanism for coordinating what users see with application data values.
  While we could push values to and pull values from HTML,
  the application is easier to write, read, and maintain if we turn these chores over to a binding framework.
  We simply declare bindings between binding sources and target HTML elements and let the framework do the work.

  Angular는 다양한 데이터 바인딩을 제공하고, 이번 챕터에서 각각에 대해 논의하겠습니다.
  우선 Angular 데이터 바인딩과 그 구문에 대해 개괄적으로 살펴보겠습니다.

  Angular provides many kinds of data binding, and we’ll discuss each of them in this chapter.
  First we'll take a high-level view of Angular data binding and its syntax.

  모든 바인딩은 데이터가 흐르는 방향에 따라 세 가지 카테고리로 나눌 수 있습니다.
  각 카테고리는 그것만의 고유한 구문을 가지고 있습니다:

  We can group all bindings into three categories by the direction in which data flows.
  Each category has its distinctive syntax:
table
  tr
    th
      p 데이터 방향
      p Data direction
    th
      p 구문
      p Syntax
    th
      p 바인딩 유형
      p Binding type
  tr
    td
      p 단방향
      p One-way
      p 데이터 소스에서
      p from data source
      p 뷰 타겟으로
      p to view target
    td
      code-example().
        {{expression}}
        [target] = "expression"
        bind-target = "expression"
    td
      p 삽입식
      p Interpolation
      p 프로퍼티
      p Property
      p 속성
      p Attribute
      p 클래스
      p Class
      p 스타일
      p Style
    tr
      td
        p 단방향
        p One-way
        p 뷰 타겟에서
        p from view target
        p 데이터 소스로
        p to data source
      td
        code-example().
          (target) = "statement"
          on-target = "statement"
      td
        p 이벤트
        p Event
    tr
      td
        p 양방향
        p Two-way
      td
        code-example().
          [(target)] = "expression"
          bindon-target = "expression"
      td
        p 양방향
        p Two-way

:marked
  삽입식 이외의 바인딩 유형은 등호의 왼쪽에 **타겟 이름**을 가집니다,
  이것들은 구두점 (`[]`, `()`)으로 둘러싸이거나 접두어 (`bind-`, `on-`, `bindon-`)가 있습니다.

  Binding types other than interpolation have a **target name** to the left of the equal sign,
  either surrounded by punctuation (`[]`, `()`) or preceded by a prefix (`bind-`, `on-`, `bindon-`).

  그것들의 타겟은 무엇일까요? 이 질문에 답하기 전에, 템플릿 HTML을 새로운 방식으로 이해하는 도전을 해야합니다.

  What is that target? Before we can answer that question, we must challenge ourselves to look at template HTML in a new way.

  ### 새로운 멘탈 모델 (역주: 사용자가 제품을 이해하는 방식을 뜻하는 용어)
  ### A new mental model

  모든 데이터 바인딩과 사용자 정의 마크업으로 HTML 어휘를 확장하는 능력을 보면,
  템플릿 HTML을 *HTML Plus*로 생각할 수 있습니다.

  With all the power of data binding and our ability to extend the HTML vocabulary
  with custom markup, it is tempting to think of template HTML as *HTML Plus*.

  그렇습니다. 그것은 HTML Plus *입니다*.
  그러나 그것은 또한 우리가 사용해왔던 HTML과는 완전히 다릅니다.
  우리는 정말로 완전히 새로운 멘탈 모델이 필요합니다.

  Well, it *is* HTML Plus.
  But it’s also significantly different than the HTML we’re used to.
  We really need a new mental model.

  일반적인 HTML 개발 과정에서, 우리는 HTML 엘리먼트로 비주얼 구조를 만들고,
  엘리먼트 속성에 문자열 상수를 설정하여 그러한 엘리먼트를 수정합니다.

  In the normal course of HTML development, we create a visual structure with HTML elements, and
  we modify those elements by setting element attributes with string constants.

+makeExample('template-syntax/ts/app/app.component.html', 'img+button')(format=".")
:marked
  우리는 여전히 Angular 템플릿에서 구조를 만들고 속성 값을 초기화 합니다.

  We still create a structure and initialize attribute values this way in Angular templates.

  그런 다음, HTML을 캡슐화하는 컴포넌트로 새로운 엘리먼트를 만들고
  마치 그것들이 네이티브 HTML 엘리먼트인 것처럼 템플릿에 놓았습니다.

  Then we learn to create new elements with components that encapsulate HTML
  and drop them into our templates as if they were native HTML elements.
+makeExample('template-syntax/ts/app/app.component.html', 'hero-detail-1')(format=".")
:marked
  이것이 HTML Plus 입니다.

  That’s HTML Plus.

  이제 데이터 바인딩을 배워보겠습니다. 첫 번째 만날 바인딩은 다음과 같습니다:

  Now we start to learn about data binding. The first binding we meet might look like this:

+makeExample('template-syntax/ts/app/app.component.html', 'disabled-button-1')(format=".")
:marked
  특유의 대괄호 표기법을 잠깐 살펴보겠습니다. 그것을 넘어서,
  우리는 직감으로는 버튼의 `disabled` 속성에 바인딩하고,
  그것을 `isUnchanged` 컴포넌트 프로퍼티의 현재 값으로 설정할 것 같습니다.

  We’ll get to that peculiar bracket notation in a moment. Looking beyond it,
  our intuition tells us that we’re binding to the button's `disabled` attribute and setting
  it to the current value of the component’s `isUnchanged` property.

  우리의 직감이 틀렸습니다! 일상적인 HTML 멘탈 모델이 우리를 오해하게 만들었습니다.
  사실, 데이터 바인딩을 시작하면 더 이상 HTML *속성*과 작업을 하지 않습니다. 우리는 속성을 설정하지 않습니다.
  우리는 DOM 엘리먼트, 컴포넌트, 그리고 지시자의 *속성*을 설정합니다.

  Our intuition is wrong! Our everyday HTML mental model is misleading us.
  In fact, once we start data binding, we are no longer working with HTML *attributes*. We aren't setting attributes.
  We are setting the *properties* of DOM elements, components, and directives.

.l-sub-section
  :marked
    ### HTML 속성 vs DOM 프로퍼티
    ### HTML attribute vs. DOM property

    HTML 속성과 DOM 프로퍼티의 차이는 Angular 바인딩이 어떻게 동작하는지 이해하는데 매우 중요합니다.

    The distinction between an HTML attribute and a DOM property is crucial to understanding how Angular binding works.

    **속성은 HTML에 의해 정의됩니다. 프로퍼티는 DOM (Document Object Model)에 의해 정의됩니다.**

    **Attributes are defined by HTML. Properties are defined by the DOM (Document Object Model).**

    * 일부 HTML 속성은 프로퍼티와 1:1 매핑됩니다. `id`가 한 예입니다.

    * A few HTML attributes have 1:1 mapping to properties. `id` is one example.

    * 일부 HTML 속성은 대응하는 프로퍼티가 없습니다. `colspan`이 한 예입니다.

    * Some HTML attributes don't have corresponding properties. `colspan` is one example.

    * 일부 DOM 프로퍼티는 대응하는 속성이 없습니다. `textContent`가 한 예입니다.

    * Some DOM properties don't have corresponding attributes. `textContent` is one example.

    * 많은 HTML 속성은 프로퍼티에 대응됩니다 ... 그러나 우리가 생각하는 방식은 아닙니다.

    * Many HTML attributes appear to map to properties ... but not in the way we might think!

    마지막 카테고리는 특히 헷갈릴 수 있습니다 ... 이런 일반적인 규칙을 이해하기 전까지는요:

    That last category can be especially confusing ... until we understand this general rule:

    **속성은 DOM 프로퍼티를 *초기화* 한 다음 완료됩니다.
    프로퍼티 값은 변합니다; 속성 값은 그렇지 않습니다.**

    **Attributes *initialize* DOM properties and then they are done.
    Property values can change; attribute values can't.**

    예를들어, 브라우저가 `<input type="text" value="Bob">`을 렌더링하면,
    "Bob"으로 *초기화 된* `value` 속성을 가진 DOM 노드를 생성합니다.

    For example, when the browser renders `<input type="text" value="Bob">`, it creates a
    corresponding DOM node with a `value` property *initialized* to "Bob".

    사용자가 "Sally"를 입력 상자에 입력하면, DOM 엘리먼트 `value` *프로퍼티*는 "Sally"가 됩니다.
    그러나 HTML `value` *속성*은 변경되지 않은 채로 남아있습니다.
    다음 처럼 입력 엘리먼트에 질의하여 확인할 수 있습니다: `input.getAttribute('value') // "Bob"을 반환`

    When the user enters "Sally" into the input box, the DOM element `value` *property* becomes "Sally".
    But the HTML `value` *attribute* remains unchanged as we discover if we ask the input element
    about that attribute: `input.getAttribute('value') // returns "Bob"`

    HTML 속성 `value`는 *초기* 값을 지정합니다; DOM `value` 프로퍼티는 *현재* 값입니다.

    The HTML attribute `value` specifies the *initial* value; the DOM `value` property is the *current* value.

    `disabled` 속성은 또다른 특수한 예입니다. `disabled` 버튼 *속성*의
    기본값은 `false`이므로 버튼은 활성화 되어 있습니다.
    만약 `disabled` *속성*을 추가하면, 그것의 존재만으로 버튼의 `disabled` *속성*은
    `true`로 초기화되어 버튼은 비활성화 됩니다.

    The `disabled` attribute is another peculiar example. A button's `disabled` *property* is
    `false` by default so the button is enabled.
    When we add the `disabled` *attribute*, its presence alone initializes the  button's `disabled` *property* to `true`
    so the button is disabled.

    `disabled` *속성*을 추가 및 제거하는 것으로 버튼을 비활성화 및 활성화 합니다. *속성*의 값은 관련이 없습니다,
    이것이 `<button disabled="false">Still Disabled</button>`처럼 작성하여 버튼을 활성화 할 수 없는 이유입니다.

    Adding and removing the `disabled` *attribute* disables and enables the button. The value of the *attribute* is irrelevant,
    which is why we cannot enable a button by writing `<button disabled="false">Still Disabled</button>`.

    버튼의 `disabled` *속성*을 설정하는 것은 (즉, Angular 바인딩을 사용하여) 버튼을 비활성화하거나 활성화 합니다.
    *프로퍼티*의 값이 중요한 것입니다.

    Setting the button's `disabled` *property*  (say, with an Angular binding) disables or enables the button.
    The value of the *property* matters.

    **HTML 속성과 DOM 프로퍼티는 같은 것이 아닙니다. 심지어 같은 이름을 가졌을때도요.**

    **The HTML attribute and the DOM property are not the same thing, even when they have the same name.**

:marked
  이것은 매우 중요합니다. 다시 한번 말하겠습니다.
  
  This is so important, we’ll say it again.

  **템플릿 바인딩은 *프로퍼티*와 *이벤트*로 동작합니다, *속성*이 아닙니다.**

  **Template binding works with *properties* and *events*, not *attributes*.**

.callout.is-helpful
  header 속성이 없는 세상
  header A world without attributes
  :marked
    Angular 세계에서, 속성의 유일한 역할은 엘리먼트 및 지시자 상태를 초기화 하는 것입니다.
    우리는 데이터 바인딩 시 엘리먼트와 지시자 프로퍼티와 이벤트를 배타적으로 다룹니다.
    속성은 실질적으로 사용하지 않습니다.

    In the world of Angular, the only role of attributes is to initialize element and directive state.
    When we data bind, we're dealing exclusively with element and directive properties and events.
    Attributes effectively disappear.
:marked
  이러한 모델을 확실하게 염두에 두고, 바인딩 타겟에 대해 배워보겠습니다.

  With this model firmly in mind, let's learn about binding targets.

  ### 바인딩 타겟
  ### Binding targets

  **데이터 바인딩의 타겟**은 DOM에 있는 어떤 것입니다.
  바인딩 타입에 따라, 타겟은 (엘리먼트 | 컴포넌트 | 지시자) 프로퍼티,
  (엘리먼트 | 컴포넌트 | 지시자) 이벤트, 또는 (가끔씩) 속성 이름입니다.
  다음 표에 요약했습니다:

  The **target of a data binding** is something in the DOM.
  Depending on the binding type, the target can be an
  (element | component | directive) property, an
  (element | component | directive) event, or (rarely) an attribute name.
  The following table summarizes:

//- If you update this table, UPDATE it in Dart & JS, too.
<div width="90%">
table
  tr
    th
      p 바인딩 유형
      p Binding type
    th
      p 타겟
      p Target
    th
      p 예
      p Examples
  tr
    td
      p 프로퍼티
      p Property
    td
      p 엘리먼트&nbsp;속성
      p Element&nbsp;property
      p 컴포넌트&nbsp;속성
      p Component&nbsp;property
      p 지시자&nbsp;속성
      p Directive&nbsp;property
    td
      +makeExample('template-syntax/ts/app/app.component.html', 'property-binding-syntax-1')(format=".")
  tr
    td
      p 이벤트
      p Event
    td
      p 엘리먼트&nbsp;이벤트
      p Element&nbsp;event
      p 컴포넌트&nbsp;이벤트
      p Component&nbsp;event
      p 지시자&nbsp;이벤트
      p Directive&nbsp;event
    td
      +makeExample('template-syntax/ts/app/app.component.html', 'event-binding-syntax-1')(format=".")
  tr
    td
      p 양방향
      p Two-way
    td
      p 이벤트와 프로퍼티
      p Event and property
    td
      +makeExample('template-syntax/ts/app/app.component.html', '2-way-binding-syntax-1')(format=".")
  tr
    td
      p 속성
      p Attribute
    td
      p 속성
      p Attribute
      p (예외)
      p (the&nbsp;exception)
    td
      +makeExample('template-syntax/ts/app/app.component.html', 'attribute-binding-syntax-1')(format=".")
  tr
    td
      p 클래스
      p Class
    td
      p <code>클래스</code> 프로퍼티
      p <code>class</code> property
    td
      +makeExample('template-syntax/ts/app/app.component.html', 'class-binding-syntax-1')(format=".")
  tr
    td
      p 스타일
      p Style
    td
      p <code>스타일</code> 프로퍼티
      p <code>style</code> property
    td
      +makeExample('template-syntax/ts/app/app.component.html', 'style-binding-syntax-1')(format=".")
</div>

:marked
  설계 단계(architectural clouds)에서 내려와 바인딩 유형을 구체적으로 살펴보겠습니다.

  Let’s descend from the architectural clouds and look at each of these binding types in concrete detail.

.l-main-section
:marked
  ## 프로퍼티 바인딩
  ## Property binding

  뷰 엘리먼트의 프로퍼티를 [템플릿 표현식](#template-expressions) 값에 설정하고 싶을 때
  템플릿 **프로퍼티 바인딩**을 사용했습니다.

  We write a template **property binding** when we want to set a property of a view element to the value of
  a [template expression](#template-expressions).

  가장 일반적인 프로퍼티 바인딩은 엘리먼트 프로퍼티를 컴포넌트 프로퍼티 값으로 설정하는 것입니다.
  예제는 이미지 엘리먼트의 `src` 프로퍼티를 컴포넌트의 `heroImageUrl` 프로퍼티에 바인딩합니다:

  The most common property binding sets an element property to a component property value. An example is
  binding the `src` property of an image element to a component’s `heroImageUrl` property:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-1')(format=".")
:marked
  다른 예제는 컴포넌트가 `isUnchanged`라고 알려주면 버튼을 비활성화 합니다:

  Another example is disabling a button when the component says that it `isUnchanged`:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-2')(format=".")
:marked
  다른 것은 지시자의 프로퍼티를 설정합니다:

  Another is setting a property of a directive:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-3')(format=".")
:marked
  또 다른 것은 사용자 컴포넌트의 모델 프로퍼티를 설정합니다.
  (부모와 자식 컴포넌트가 통신하기 위한 뛰어난 방법)

  Yet another is setting the model property of a custom component (a great way
  for parent and child components to communicate):
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-4')(format=".")
:marked
  ### 단방향 *in*
  ### One-way *in*

  사람들은 종종 프로퍼티 바인딩을 *단방향 데이터 바인딩*이라고 묘사합니다.
  왜냐하면 값이, 컴포넌트의 데이터 프로퍼티에서 타겟 엘리먼트의 프로퍼티로, 한 방향으로 흐르기 때문입니다.

  People often describe property binding as *one-way data binding* because it flows a value in one direction,
  from a component’s data property into a target element property.

  우리는 프로퍼티 바인딩을 사용하여 타겟 엘리먼트에서 값을 가져올 수 없습니다.
  우리는 타겟 엘리먼트의 프로퍼티를 읽기 위해 바인딩 할 수 없습니다. 오직 설정할 수만 있습니다.

  We cannot use property binding to pull values *out* of the target element.
  We can't bind to a property of the target element to read it. We can only set it.

.l-sub-section
  :marked
    또한 프로퍼티 바인딩을 사용해 타겟 엘리먼트의 메소드를 *호출*할 수도 없습니다.

    Nor can we use property binding to *call* a method on the target element.

    만약 엘리먼트에서 이벤트가 발생하면, [이벤트 바인딩](#event-binding)으로 그것들을 들을 수 있습니다.

    If the element raises events we can listen to them with an [event binding](#event-binding).

    만약 타겟 엘리먼트 속성을 읽어야 하거나 그것의 메소드를 호출해야 한다면,
    다른 기술이 필요합니다.
    [ViewChild](../api/core/index/ViewChild-decorator.html) 와
    [ContentChild](../api/core/index/ContentChild-decorator.html)에 있는
    API 참조설명을 보세요.

    If we must read a target element property or call one of its methods,
    we'll need a different technique.
    See the API reference for
    [ViewChild](../api/core/index/ViewChild-decorator.html) and
    [ContentChild](../api/core/index/ContentChild-decorator.html).

:marked
  ### 바인딩 타겟
  ### Binding target

  닫혀 있는 대괄호 사이의 엘리먼트 프로퍼티는 타겟 프로퍼티를 식별합니다. 다음 코드의 타겟 프로퍼티는 이미지 엘리먼트의 `src` 프로퍼티입니다.

  An element property between enclosing square brackets identifies the target property. The target property in the following code is the image element’s `src` property.

+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-1')(format=".")
:marked
  어떤 사람들은 *정규형*으로 알려진 `bind-` 접두어 방식을 선호합니다.

  Some people prefer the `bind-` prefix alternative, known as the *canonical form*:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-5')(format=".")
:marked
  타겟 이름은 다른 것의 이름으로 보이지만 항상 프로퍼티의 이름입니다. `src`를 보면 아마 속성의 이름이라고 생각할 것입니다. 아닙니다. 그것은 이미지 엘리먼트 프로퍼티의 이름입니다.

  The target name is always the name of a property, even when it appears to be the name of something else. We see `src` and may think it’s the name of an attribute. No. It’s the name of an image element property.

  엘리먼트 프로퍼티가 보다 일반적인 타겟일 것입니다.
  그러나 다음 예제에 있는 것처럼 Angular는
  알려진 이름의 지시자 프로퍼티인지 먼저 확인합니다.

  Element properties may be the more common targets,
  but Angular looks first to see if the name is a property of a known directive,
  as it is in the following example:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-3')(format=".")

.l-sub-section
  :marked
    기술적으로, Angular는 이름을 [input](#inputs-outputs)지시자에서 찾아봅니다,
    이것은 지시자의 `inputs` 배열이나 `@Input()`으로 장식된 프로퍼티에 나열한 프로퍼티 이름 중 하나입니다.
    이런 input을 지시자의 자체 프로퍼티에 매핑합니다.

    Technically, Angular is matching the name to a directive [input](#inputs-outputs),
    one of the property names listed in the directive’s `inputs` array or a property decorated with `@Input()`.
    Such inputs map to the directive’s own properties.
:marked
  만약 알려진 지사자나 엘리먼트에서 찾지 못하면, Angular는 “unknown directive”를 보고합니다.

  If the name fails to match a property of a known directive or element, Angular reports an “unknown directive” error.

  ### 부작용 회피
  ### Avoid side effects

  이미 논의한 것처럼, 템플릿 표현식 평가는 표시 부작용이 없어야 합니다.
  표현식 언어 자체는 우리를 안전하게 지켜주는 역할을 합니다.
  프로퍼티 바인딩 표현식의 어떤 것에도 값을 할당할 수 없고 증감 연산자도 사용할 수 없습니다.
  
  As we've already discussed, evaluation of a template expression should have no visible side effects. The expression language itself does its part to keep us safe. We can’t assign a value to anything in a property binding expression nor use the increment and decrement operators.

  물론, 표현식은 부작용이 있는 프러퍼티나 메소드를 호출 할 수 있습니다. Angular가 이것을 알고 멈추게할 방법은 없습니다.

  Of course, our expression might invoke a property or method that has side effects. Angular has no way of knowing that or stopping us.

  표현식은 `getFoo()`같은 것을 호출할 수 있습니다. 오직 우리만 `getFoo()`가 무엇을 하는지 알고 있습니다.
  만약 `getFoo()`가 무엇인가를 변경하고 그 무엇에 바인딩하면, 안 좋은 경험을 할 위험이 있습니다.
  Angular는 변경된 값을 표시할 수도 표시하지 않을 수도 있습니다. Angular는 변경을 감지하고
  경고 에러를 던질 수도 있습니다. 일반적인 조언: 데이터 프로퍼티와 값을 반환하고 아무것도 하지 않는 메소드 사용을 고수하세요.

  The expression could call something like `getFoo()`. Only we know what `getFoo()` does.
  If `getFoo()` changes something and we happen to be binding to that something, we risk an unpleasant experience. Angular may or may not display the changed value. Angular may detect the change and throw a warning error. Our general advice: stick to data properties and to methods that return values and do no more.

  ### 적절한 타입을 반환
  ### Return the proper type

  템플릿 표현식은 타겟 프로퍼티가 예상하는 값의 타입으로 평가되어야만 합니다.
  만약 타겟 프로퍼티가 문자열을 기대하고 있으면 문자열을 반환해야 합니다.
  만약 타겟 프로퍼티가 숫자를 기대하고 있으면 숫자를 반환해야 합니다.
  만약 타겟 프로퍼티가 객체를 기대하고 있으면 객체를 반환해야 합니다.

  The template expression should evaluate to the type of value expected by the target property.
  Return a string if the target property expects a string.
  Return a number if the target property expects a number.
  Return an object if the target property expects an object.

  `HeroDetail` 컴포넌트의 `hero` 프로퍼티는 `Hero` 객체를 기대합니다.
  이것이 정확히 프로퍼티 바인딩에서 보내는 것입니다:

  The `hero` property of the `HeroDetail` component expects a `Hero` object, which is exactly what we’re sending in the property binding:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-4')(format=".")

block dart-type-exceptions
  //- N/A

:marked
  ### 대괄호를 기억하세요
  ### Remember the brackets

  대괄호는 Angular에게 템플릿 표현식을 평가하라고 알려줍니다.
  만약 대괄호를 빼먹으면, Angular는 문자열을 상수로 다루고 
  그 문자열로 *타겟 프로퍼티를 초기화*합니다.
  문자열을 평가하지 *않습니다*!

  The brackets tell Angular to evaluate the template expression.
  If we forget the brackets, Angular treats the string as a constant and *initializes the target property* with that string.
  It does *not* evaluate the string!

  다음과 같은 실수를 저지르지 마세요:

  Don't make the following mistake:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-6')(format=".")

block dart-type-exception-example
  //- N/A

a(id="one-time-initialization")
:marked
  ### 일회성 문자열 초기화
  ### One-time string initialization

  다음이 모두 참인 경우 대괄호를 제거 *해야만* 합니다:

  We *should* omit the brackets when all of the following are true:

  * 타겟 프로퍼티가 문자열 값을 받음.

  * The target property accepts a string value.

  * 문자열이 템플릿 안에서 처리 가능한 고정된 값임.

  * The string is a fixed value that we can bake into the template.

  * 초기 값이 절대 변경되지 않음.

  * This initial value never changes.

  일반적으로 표준 HTML에서는 이런 방법으로 속성을 초기화합니다.
  또한 지시자나 컴포넌트 초기화에서는 잘 작동합니다.
  다음 예제는 `HeroDetailComponent`의 `prefix` 속성을 템플릿 표현식이 아닌 고정된 문자열로 초기화 합니다.
  Angular는 그것을 셋팅하고 잊어버립니다.

  We routinely initialize attributes this way in standard HTML, and it works
  just as well for directive and component property initialization.
  The following example initializes the `prefix` property of the `HeroDetailComponent` to a fixed string,
  not a template expression. Angular sets it and forgets about it.
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-7')(format=".")
:marked
  반면에 `[hero]` 바인딩은 컴포넌트의 `currentHero` 프로퍼티에 유효한 바인딩으로 남아있습니다.

  The `[hero]` binding, on the other hand, remains a live binding to the component's `currentHero` property.

  ### 프로퍼티 바인딩? 삽입식?
  ### Property binding or interpolation?
  종종 삽입식과 프로퍼티 바인딩 사이에서 선택을 해야 합니다.
  다음 바인딩 쌍은 같은 역할을 합니다:

  We often have a choice between interpolation and property binding. 
  The following binding pairs do the same thing:
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-vs-interpolation')(format=".")
:marked
  _삽입식_은 많은 경우에 _프로퍼티 바인딩_의 편리한 대안입니다.

  _Interpolation_ is a convenient alternative to _property binding_ in many cases.

  데이터 값을 문자열로 렌더링 할 때, 하나의 방식을 선호할 기술적인 이유는 없습니다.
  우리는 가독성 때문에 삽입식을 선호하는 경향이 있습니다.
  코딩 스타일 규칙을 정하고 현재 실무에 가장 자연스러운 느낌을 주는
  방식으로 선택하는 것이 좋습니다.

  When rendering data values as strings, there is no technical reason to prefer one form to the other.
  We lean toward readability, which tends to favor interpolation.
  We suggest establishing coding style rules and choosing the form that
  both conforms to the rules and feels most natural for the task at hand.

  엘리먼트 프로퍼티를 문자열이 아닌 데이터 값에 셋팅할 때는 반드시 _프로퍼티 바인딩_을 사용해야 합니다.

  When setting an element property to a non-string data value, you must use _property binding_.

:marked
  #### 컨텐츠 보안
  #### Content security
  다음과 같은 *악성 컨텐츠*를 가정해보겠습니다.

  Imagine the following *malicious content*.
+makeExample('template-syntax/ts/app/app.component.ts', 'evil-title')(format=".")    
:marked
  다행히도, Angular 데이터 바인딩은 위험한 HTML에 대해 경고해줍니다.
  그것들을 표시하기 전에 값을 *정제*합니다.
  삽입식이나 프로퍼티 바인딩에서 스크립트 태그를 가진 HTML이 
  브라우저에 노출되지 *않도록* 합니다.

  Fortunately, Angular data binding is on alert for dangerous HTML.
  It *sanitizes* the values before displaying them.
  It **will not** allow HTML with script tags to leak into the browser, neither with interpolation
  nor property binding.
+makeExample('template-syntax/ts/app/app.component.html', 'property-binding-vs-interpolation-sanitization')(format=".")    
:marked
  삽입식은 스크립트 태그를 프로퍼티 바인딩과 다르게 다룹니다. 
  그러나 두가지 방법 모두 컨텐츠를 무해하게 렌더링합니다.

  Interpolation handles the script tags differently than property binding but both approaches render the
  content harmlessly.
figure.image-display
  img(src='/resources/images/devguide/template-syntax/evil-title.png' alt="evil title made safe" width='500px')

.l-main-section
:marked
  <a id="other-bindings"></a>
  ## 속성, 클래스, 스타일 바인딩
  ## Attribute, class, and style bindings
  템플릿 구문은 프로퍼티 바인딩이 적합하지 않은 시나리오를 위해 특화된 단방향 바인딩을 제공합니다.

  The template syntax provides specialized one-way bindings for scenarios less well suited to property binding.

  ### 속성 바인딩
  ### Attribute binding

  **속성 바인딩**으로 직접 속성의 값을 설정할 수 있습니다.

  We can set the value of an attribute directly with an **attribute binding**.
.l-sub-section
  :marked
    이것은 바인딩이 타겟 프로퍼티를 셋팅한다는 규칙에 대한 유일한 예외사항입니다. 이것은 속성을 생성하고 설정하는 유일한 바인딩입니다.

    This is the only exception to the rule that a binding sets a target property. This is the only binding that creates and sets an attribute.

:marked
  이번 챕터에서는 프로퍼티 바인딩으로 엘리먼트 프로퍼티를 설정하는 것이 문자열로 속성을 설정하는 것보다 항상 좋다고 강조했습니다. Angular는 왜 속성 바인딩을 제공할까요?

  We have stressed throughout this chapter that setting an element property with a property binding is always preferred to setting the attribute with a string. Why does Angular offer attribute binding?

  **바인딩 할 엘리먼트 프로퍼티가 없을 경우에는 반드시 속성 바인딩을 사용해야 합니다.**

  **We must use attribute binding when there is no element property to bind.**

  [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA),
  [SVG](https://developer.mozilla.org/en-US/docs/Web/SVG), 그리고
  테이블 span 속성을 생각해보세요. 이것들은 순수한 속성입니다.
  엘리먼트 프로퍼티에 해당하지는 않으며, 이것들은 엘리먼트 프로퍼티를 설정하지 않습니다.
  이것들은 바인딩할 프로퍼티 타겟이 없습니다.  

  Consider the [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA),
  [SVG](https://developer.mozilla.org/en-US/docs/Web/SVG), and
  table span attributes. They are pure attributes.
  They do not correspond to element properties, and they do not set element properties.
  There are no property targets to bind to.

  다음과 같은 것을 작성하려고 하면 이 사실을 어렵게 알 수 있습니다.

  We become painfully aware of this fact when we try to write something like this:
code-example(language="html").
  &lt;tr>&lt;td colspan="{{1 + 1}}">Three-Four&lt;/td>&lt;/tr>
:marked
  이런 에러가 발생합니다:

  We get this error:
code-example(format="nocode").
  Template parse errors:
  Can't bind to 'colspan' since it isn't a known native property
:marked
  메시지는 `<td>` 엘리먼트가 `colspan` 프로퍼티를 가지고 있지 않다고 말하고 있습니다.
  "colspan" *속성*은 가지고 있지만, 삽입식과 프로퍼티 바인딩은 속성이 아닌 오직
  *프로퍼티*만 설정할 수 있습니다.
  
  As the message says, the `<td>` element does not have a `colspan` property.
  It has the "colspan" *attribute*, but
  interpolation and property binding can set only *properties*, not attributes.

  이러한 속성을 생성하고 바인딩하려면 속성 바인딩이 필요합니다.

  We need attribute bindings to create and bind to such attributes.

  속성 바인딩 구문은 프로퍼티 바인딩과 비슷합니다.
  대괄호 사이의 엘리먼트 프로퍼티 대신에, **`attr`**로 시작하고,
  점(`.`)과 속성의 이름을 붙입니다. 
  그 다음 문자열을 나타내는 표현식을 사용해 속성값을 설정합니다.

  Attribute binding syntax resembles property binding.
  Instead of an element property between brackets, we start with the prefix **`attr`**,
  followed by a dot (`.`) and the name of the attribute. We then set the attribute
  value, using an expression that resolves to a string.

  `[attr.colspan]`을 계산된 값에 바인딩했습니다:

  Here we bind `[attr.colspan]` to a calculated value:
+makeExample('template-syntax/ts/app/app.component.html', 'attrib-binding-colspan')(format=".")
:marked
  다음은 테이블을 렌더링하는 방법입니다:

  Here's how the table renders:
  <table border="1px">
    <tr><td colspan="2">One-Two</td></tr>
    <tr><td>Five</td><td>Six</td></tr>
   </table>

  속성 바인딩의 주요 사례 중 하나는 
  다음 예처럼 ARIA 속성을 설정하는 것입니다:  

  One of the primary use cases for attribute binding
  is to set ARIA attributes, as in this example:
+makeExample('template-syntax/ts/app/app.component.html', 'attrib-binding-aria')(format=".")
:marked
  ### 클래스 바인딩
  ### Class binding

  **클래스 바인딩**으로 엘리먼트의 `class` 속성에서 
  CSS 클래스 이름을 추가하거나 제거할 수 있습니다.

  We can add and remove CSS class names from an element’s `class` attribute with
  a **class binding**.

  클래스 바인딩 구문은 프로퍼티 바인딩과 비슷합니다.
  괄호 사이의 엘리먼트 프로퍼티 대신에, `class`로 시작하고,
  선택적으로 점 (`.`)과 CSS 클래스 이름을 붙입니다: `[class.class-name]`.

  Class binding syntax resembles property binding.
  Instead of an element property between brackets, we start with the prefix `class`,
  optionally followed by a dot (`.`) and the name of a CSS class: `[class.class-name]`.

  다음 예제는 클래스 바인딩으로 애플리케이션의 "special" 클래스를 추가하고 제거하는 방법을
  보여줍니다. 바인딩을 사용하지 않고 속성을 설정하는 방법은 다음과 같습니다:

  The following examples show how to add and remove the application's "special" class
  with class bindings.  Here's how we set the attribute without binding:
+makeExample('template-syntax/ts/app/app.component.html', 'class-binding-1')(format=".")
:marked
  이것을 원하는 클래스 이름의 문자열에 바인딩할 수도 있습니다; 이렇게 하면 전부 바인딩 되거나 아무것도 바인딩 되지 않습니다.

  We can replace that with a binding to a string of the desired class names; this is an all-or-nothing, replacement binding.
+makeExample('template-syntax/ts/app/app.component.html', 'class-binding-2')(format=".")

:marked
  마지막으로 특별한 클래스 이름에 바인딩할 수 있습니다.
  Angular는 템플릿 표현식이 #{_truthy_ko}으로 평가될 때 클래스를 더합니다.
  표현식이 #{_falsey_ko}인 경우 클래스를 제거합니다.

  Finally, we can bind to a specific class name.
  Angular adds the class when the template expression evaluates to #{_truthy}.
  It removes the class when the expression is #{_falsey}.
+makeExample('template-syntax/ts/app/app.component.html', 'class-binding-3')(format=".")

.l-sub-section
  :marked
    비록 이것이 단일 클래스 이름을 토글하는 좋은 방법이지만,
    여러 클래스 이름을 동시에 관리하기 위해서는 일반적으로 [NgClass 지시자](#ngClass)를 선호합니다.

    While this is a fine way to toggle a single class name,
    we generally prefer the [NgClass directive](#ngClass) for managing multiple class names at the same time.

:marked
  ### 스타일 바인딩
  ### Style binding

  **스타일 바인딩**으로 인라인 스타일을 설정할 수 있습니다.

  We can set inline styles with a **style binding**.

  스타일 바인딩 구문은 프로퍼티 바인딩과 비슷합니다.
  대괄호 사이에 엘리먼트 프로퍼티 대신에, `style`로 시작하고,
  점 (`.`)과 CSS 스타일 프로퍼티의 이름을 붙입니다: `[style.style-property]`.

  Style binding syntax resembles property binding.
  Instead of an element property between brackets, we start with the prefix `style`,
  followed by a dot (`.`) and the name of a CSS style property: `[style.style-property]`.

+makeExample('template-syntax/ts/app/app.component.html', 'style-binding-1')(format=".")
:marked
  어떤 스타일 바인딩의 스타일은 단위 확장자가 있습니다. 다음은 조건에 따라 글꼴 크기를 “em” 및 “%”로 설정합니다.

  Some style binding styles have unit extension. Here we conditionally set the font size in  “em” and “%” units .
+makeExample('template-syntax/ts/app/app.component.html', 'style-binding-2')(format=".")

.l-sub-section
  :marked
    비록 이것인 단일 스타일에는 좋은 방법이지만,
    여러 인라인 스타일을 동시에 설정할 때는 일반적으로 [NgStyle 지시자](#ngStyle)를 선호합니다.

    While this is a fine way to set a single style,
    we generally prefer the [NgStyle directive](#ngStyle) when setting several inline styles at the same time.

.l-sub-section
  :marked
    _스타일 프로퍼티_ 이름은 
    위에서 본 것처럼 [dash-case](glossary.html#dash-case)으로 쓰여지거나,
    `fontSize`처럼 [camelCase](glossary.html#camelcase)로 쓰여질 수 있습니다.

    Note that a _style property_ name can be written in either
    [dash-case](glossary.html#dash-case), as shown above, or
    [camelCase](glossary.html#camelcase), such as `fontSize`.

block style-property-name-dart-diff
  //- N/A

.l-main-section
:marked
  ## 이벤트 바인딩
  ## Event binding
  지금껏 살펴본 바인딩은 데이터가 한 방향으로 흘렀습니다: **컴포넌트에서 엘리먼트로**.

  The bindings we’ve met so far flow data in one direction: **from a component to an element**.

  사용자가 화면을 응시만 하는 것은 아닙니다. 그들은 입력 상자에 텍스트를 입력합니다. 그들은 리스트에서 아이템을 선택합니다.
  그들은 버튼을 클릭합니다. 이러한 사용자 액션은 데이터가 반대편 방향으로 흐르게 합니다:
  **엘리먼트에서 컴포넌트로**.

  Users don’t just stare at the screen. They enter text into input boxes. They pick items from lists.
  They click buttons. Such user actions may result in a flow of data in the opposite direction:
  **from an element to a component**.

  사용자 액션을 알 수 있는 유일한 방법은 키입력, 마우스 움직임, 클릭, 터치와 같은 
  특정 이벤트를 듣는 것입니다.
  Angular 이벤트 바인딩을 통해 사용자 액션 중 관심있는 것을 선언합니다.

  The only way to know about a user action is to listen for certain events such as
  keystrokes, mouse movements, clicks, and touches.
  We declare our interest in user actions through Angular event binding.

  이벤트 바인딩 문법은 등호의 왼쪽에 소괄호로 둘러싸인 **타겟 이벤트**와 
  등호의 오른쪽에 따옴표로 둘러싸인 [템플릿 명령문](#template-statements)으로 구성됩니다.
  다음 이벤트 바인딩은 버튼의 클릭 이벤트를 듣고,
  클릭이 발생할 때마다 컴포넌트의 `onSave()` 메소드를 호출합니다:

  Event binding syntax consists of a **target event** within parentheses on the left of an equal sign, and a quoted
  [template statement](#template-statements) on the right.
  The following event binding listens for the button’s click event, calling
  the component's `onSave()` method whenever a click occurs:
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-1')(format=".")
:marked
  ### 타겟 이벤트
  ### Target event
  **소괄호 사이의 이름**은 &mdash; 예를 들어, `(click)` &mdash;
  타겟 이벤트를 식별합니다. 다음 예제에서, 타겟은 버튼의 클릭 이벤트 입니다.

  A **name between parentheses** &mdash; for example, `(click)` &mdash;
  identifies the target event. In the following example, the target is the button’s click event.
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-1')(format=".")
:marked
  어떤 사람들은 **정규형**으로 알려진 `on-` 접두어 방식을 선호합니다.

  Some people prefer the `on-` prefix alternative, known as the **canonical form**:
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-2')(format=".")
:marked
  엘리먼트 이벤트는 보다 일반적인 타겟일 것입니다, 그러나 Angular는 알려진 지시자의 이벤트 프로퍼티인지
  먼저 확인합니다. 다음 예제에서 처리하는 방식입니다:

  Element events may be the more common targets, but Angular looks first to see if the name matches an event property
  of a known directive, as it does in the following example:
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-3')(format=".")

.l-sub-section
  :marked
    `myClick` 지사자는 [인풋/아웃풋 프로퍼티에 별칭 붙이기](#aliasing-io)
    에서 보다 자세히 설명하겠습니다.

    The `myClick` directive is further described in the section
    on [aliasing input/output properties](#aliasing-io).

:marked
  그 이름과 같은 엘리먼트 이벤트 또는 알려진 지시자의 아웃풋 프로퍼티를 찾지 못했다면,
  Angular는 “unknown directive” 에러를 보고합니다.

  If the name fails to match an element event or an output property of a known directive,
  Angular reports an “unknown directive” error.

  ### *$event* 와 이벤트 핸들링 명령문
  ### *$event* and event handling statements

  이벤트 바인딩에서, Angular는 타겟 이벤트에 이벤트 핸들러를 설정합니다.

  In an event binding, Angular sets up an event handler for the target event.

  이벤트가 발생하면, 핸들러는 템플릿 명령문을 실행합니다.
  템플릿 명령문은 전형적으로 수신자를 포함합니다.
  수신자는 그 이벤트에 대해 HTML 컨트롤의 값을 모델에 저장하는 것과 같은 
  액션을 수행합니다.

  When the event is raised, the handler executes the template statement.
  The template statement typically involves a receiver, which performs an action
  in response to the event, such as storing a value from the HTML control
  into a model.

  바인딩은 **`$event`라는 이벤트 객체**를 통해
  데이터 값을 포함한 이벤트에 대한 정보를 전달합니다.

  The binding conveys information about the event, including data values, through
  an **event object named `$event`**.

  이벤트 객체의 모양은 타겟 이벤트에 의해 결정됩니다.
  만약 타겟 이벤트가 네이티브 DOM 엘리먼트 이벤트라면, `$event`는
  `target` 및 `target.value`와 같은 속성을 가진
  [DOM 이벤트 객체]( https://developer.mozilla.org/en-US/docs/Web/Events)입니다.

  The shape of the event object is determined by the target event.
  If the target event is a native DOM element event, then `$event` is a
  [DOM event object]( https://developer.mozilla.org/en-US/docs/Web/Events),
  with properties such as `target` and `target.value`.

  다음 예제를 보겠습니다:

  Consider this example:
+makeExample('template-syntax/ts/app/app.component.html', 'without-NgModel')(format=".")
:marked
  이 코드는 `firstName` 프로퍼티 값을 `value` 프로퍼티에 바인딩합니다. 값의 변경을 감지하기 위해, 입력 상자의 `input` 이벤트에 바인딩합니다.
  사용자가 변화를 일으키면, `input` 이벤트가 발생하고, 바인딩은 `$event` DOM 이벤트 객체를 포함하는 객체 안에서 명령문을 실행합니다.

  This code sets the input box `value` property by binding to the `firstName` property. To listen for changes to the value, the code binds to the input box's `input` event.
  When the user makes changes, the `input` event is raised, and the binding executes the statement within a context that includes the DOM event object, `$event`.

  `firstName` 프로퍼티를 업데이트 하기 위해 `$event.target.value` 경로를 따라 변경 텍스트를 가져옵니다.

  To update the `firstName` property, the changed text is retrieved by following the path `$event.target.value`.

  만약 이벤트가 지시자에 속한다면 (컴포넌트는 지시자였던 것을 기억하세요), `$event`는 지시자가 생성하기로 결정한 어떤 형태가 됩니다.

  If the event belongs to a directive (recall that components are directives), `$event` has whatever shape the directive decides to produce.

  <a id="eventemitter"></a>
  <a id="custom-event"></a>
  ### *EventEmitter*를 사용한 커스텀 이벤트
  ### Custom events with *EventEmitter*

  지시자는 일반적으로 Angular [EventEmitter](../api/core/index/EventEmitter-class.html)
  를 사용해 커스텀 이벤트를 발생시킵니다.
  지시자는 `EventEmitter`를 생성하고 그것을 프로퍼티로 노출합니다.
  지시자는 이벤트를 발생시키기 위해 `EventEmitter.emit(payload)`를 호출합니다.
  메시지 payload로 전달되는 것은 어떤 것이든 될 수 있습니다.
  부모 지시자는 해당 프로퍼티에 바인딩하여 이벤트를 들을 수 있고
  `$event` 객체를 통해 payload에 접근할 수 있습니다.

  Directives typically raise custom events with an Angular [EventEmitter](../api/core/index/EventEmitter-class.html).
  The directive creates an `EventEmitter` and exposes it as a property.
  The directive calls `EventEmitter.emit(payload)` to fire an event, passing in a message payload, which can be anything.
  Parent directives listen for the event by binding to this property and accessing the payload through the `$event` object.

  히어로 정보를 표현하고 사용자 액션에 반응하는 `HeroDetailComponent`를 생각해보겠습니다.
  비록 `HeroDetailComponent`가 삭제 버튼을 가지고 있지만, 히어로 자신을 어떻게 지우는지 모르고 있습니다.
  그렇게 하는 최선의 방법은 사용자의 삭제 요청을 보고하는 이벤트를 발생시키는 것입니다.

  Consider a `HeroDetailComponent` that presents hero information and responds to user actions.
  Although the `HeroDetailComponent` has a delete button it doesn't know how to delete the hero itself.
  The best it can do is raise an event reporting the user's delete request.

  다음은 `HeroDetailComponent`에서 적절히 발췌한 부분입니다:

  Here are the pertinent excerpts from that `HeroDetailComponent`:
+makeExcerpt('app/hero-detail.component.ts (template)', 'template-1')
+makeExcerpt('app/hero-detail.component.ts', 'deleteRequest')

:marked
  컴포넌트는 `EventEmitter`를 반환하는 `deleteRequest` 프로퍼티를 정의합니다.
  사용자가 *삭제*를 클릭하면, 컴포넌트는 `EventEmitter`가 `Hero` 객체를 노출하라고 말하는
  `delete()` 메소드를 호출합니다.

  The component defines a `deleteRequest` property that returns an `EventEmitter`.
  When the user clicks *delete*, the component invokes the `delete()` method, 
  telling the `EventEmitter` to emit a `Hero` object.

  이제 `HeroDetailComponent`의 `deleteRequest` 이벤트에 바인딩하는 부모 컴포넌트를 상상해보세요.

  Now imagine a hosting parent component that binds to the `HeroDetailComponent`'s `deleteRequest` event.

+makeExcerpt('app/app.component.html', 'event-binding-to-component', '')

:marked
  `deleteRequest` 이벤트가 발생하면, Angular는 부모 컴포넌트의 `deleteHero` 메소드를 호출합니다.
  메소드는 `$event` 변수 안에 (`HeroDetail`이 방출하는) *삭제하려는 히어로*를 전달합니다.

  When the `deleteRequest` event fires, Angular calls the parent component's `deleteHero` method,
  passing the *hero-to-delete* (emitted by `HeroDetail`) in the `$event` variable.

  ### 템플릿 명령문의 부작용
  ### Template statements have side effects

  `deleteHero` 메소드는 부작용이 있습니다: 히어로를 삭제하는 것입니다.
  템플릿 명령문의 부작용은 단순한 문제가 아닙니다. 그러나 예상할 수 있습니다.

  The `deleteHero` method has a side effect: it deletes a hero.
  Template statement side effects are not just OK, but expected.

  히어로 삭제는 모델을 업데이트합니다. 
  아마 원격 서버에 조회하고 저장하는 것을 포함해 다른 변경사항을 유발할 것입니다.
  이러한 변경사항은 시스템을 통해 퍼지고 궁극적으로 이 화면 또는 다른 화면에 표시될 것입니다.

  Deleting the hero updates the model, perhaps triggering other changes
  including queries and saves to a remote server.
  These changes percolate through the system and are ultimately displayed in this and other views.

//-
  :marked
    ### Event bubbling and propagation [TODO: reinstate this section when it becomes true]
    Angular invokes the event-handling statement if the event is raised by the current element or one of its child elements.
  +makeExample('template-syntax/ts/app/app.component.html', 'event-binding-bubbling')(format=".")
  :marked
    Many DOM events, both [native](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Overview_of_Events_and_Handlers ) and [custom](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events ), bubble up their ancestor tree of DOM elements until an event handler along the way prevents further propagation.

  .l-sub-section
    :marked
      `EventEmitter` events don’t bubble.

  :marked
    The result of an event binding statement determines whether
    [event propagation](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation)
    continues or stops with the current element.

    Event propagation stops if the binding statement returns a falsey value (as does a method with no return value).
    Clicking the button in the next example triggers a save;
    the click doesn't make it to the outer `<div>` so the div's save handler is not called.
  +makeExample('template-syntax/ts/app/app.component.html', 'event-binding-no-propagation')(format=".")
  :marked
    Propagation continues if the statement returns a truthy value. In the next example, the click is heard by both the button
    and the outer `<div>`, causing a double save.
  +makeExample('template-syntax/ts/app/app.component.html', 'event-binding-propagation')(format=".")

#two-way
.l-main-section
:marked
  ## 양방향 바인딩
  ## Two-way binding

  우리는 종종 데이터 프로퍼티를 표시하고 사용자가 변경을 하면 그 프로퍼티를 업데이트하고 싶어 합니다.

  We often want to both display a data property and update that property when the user makes changes.

  엘리먼트 측면에서보면 특정 엘리먼트 프로퍼티로 설정하는 것과
  엘리먼트의 변경 이벤트를 듣는 것을 조합해야 합니다.

  On the element side that takes a combination of setting a specific element property
  and listening for an element change event.

  Angular는 이러한 목적을 위해 특별한 _양방향 데이터 바인딩_ 구문, **`[(x)]`** 을 제공합니다.
  `[(x)]` 구문은 프로퍼티 바인딩의 대괄호 `[x]`와 
  _이벤트 바인딩_의 소괄호 `(x)`를 조합한 것입니다.

  Angular offers a special _two-way data binding_ syntax for this purpose, **`[(x)]`**.
  The `[(x)]` syntax combines the brackets 
  of _property binding_, `[x]`, with the parentheses of _event binding_, `(x)`.

.callout.is-important
  header [( )] = 상자 안의 바나나
  header [( )] = banana in a box
  :marked
    *상자 안의 바나나*를 연상하여 대괄호 안에 들어가는 소괄호를 기억하세요.

    Visualize a *banana in a box* to remember that the parentheses go _inside_ the brackets.

:marked
  `[(x)]` 구문은 엘리먼트가 `x`라는 세터 프로퍼티를 가지고
  `xChange`라는 이벤트를 가진 경우로 쉽게 설명할 수 있습니다.
  여기에 패턴에 맞는 `SizerComponent`가 있습니다.
  `size` 값 프로퍼티와 `sizeChange` 이벤트를 동반하고 있습니다.

  The `[(x)]` syntax is easy to demonstrate when the element has a settable property called `x`
  and a corresponding event named `xChange`. 
  Here's a `SizerComponent` that fits the pattern.
  It has a `size` value property and a companion `sizeChange` event:

+makeExample('app/sizer.component.ts')

:marked
  초기 `size`는 프로퍼티 바인딩의 입력값 입니다.
  버튼을 클릭하면 min/max 값 제약 안에서 `size`가 증감하고,
  크기를 조절하면 `sizeChange` 이벤트를 발생시킵니다. (_방출합니다._)

  The initial `size` is an input value from a property binding.
  Clicking the buttons increases or decreases the `size`, within min/max values constraints,
  and then raises (_emits_) the `sizeChange` event with the adjusted size.

  다음은 `AppComponent.fontSizePx`가 `SizerComponent`에 양방향 바인딩을 하는 예제입니다:

  Here's an example in which the `AppComponent.fontSizePx` is two-way bound to the `SizerComponent`:

+makeExcerpt('app/app.component.html', 'two-way-1', '')

:marked
  `AppComponent.fontSizePx`는 초기 `SizerComponent.size` 값을 설정합니다.
  버튼 클릭은 양방향 바인딩으로 `AppComponent.fontSizePx`를 업데이트 합니다.
  수정된 `AppComponent.fontSizePx` 값은 표시 텍스트를 크게하거나 작게하는 _스타일_ 바인딩으로 흐릅니다. 
  <live-example></live-example>에서 시도해보세요.

  The `AppComponent.fontSizePx` establishes the initial `SizerComponent.size` value.
  Clicking the buttons updates the `AppComponent.fontSizePx` via the two-way binding.
  The revised `AppComponent.fontSizePx` value flows through to the _style_ binding, making the displayed text bigger or smaller.
  Try it in the <live-example></live-example>.

  양방향 바인딩 구문은 정말로 그저 _프로퍼티_ 바인딩과 _이벤트_ 바인딩을 위한 간편 표기법(syntactic sugar)입니다.
  Angular는 `SizerComponent` 바인딩을 다음과 같이 번역합니다.

  The two-way binding syntax is really just syntactic sugar for a _property_ binding and an _event_ binding.
  Angular _desugars_ the `SizerComponent` binding into this:

+makeExcerpt('app/app.component.html', 'two-way-2', '')

:marked
  `$event` 변수는 `SizerComponent.sizeChange` 이벤트의 payload를 담고 있습니다.
  Angular는 사용자가 버튼을 클릭하면 `$event` 값을 `AppComponent.fontSizePx`에 할당합니다.

  The `$event` variable contains the payload of the `SizerComponent.sizeChange` event.
  Angular assigns the `$event` value to the `AppComponent.fontSizePx` when the user clicks the buttons.

  분명히 양방향 바인딩 구문은 프로퍼티와 이벤트 바인딩을 분리하는 것에 비해 매우 편리합니다.

  Clearly the two-way binding syntax is a great convenience compared to separate property and event bindings.

  `<input>`과 `<select>` 같은 HTML 폼 엘리먼트에 양방향 바인딩을 사용하고 싶어합니다.
  애석하게도 어떠한 네이티브 HTML 엘리먼트도 `x` 값과 `xChange` 이벤트 패턴을 따르지 않습니다.

  We'd like to use two-way binding with HTML form elements like `<input>` and `<select>`.
  Sadly, no native HTML element follows the `x` value and `xChange` event pattern.

  다행히도 Angular [_NgModel_](#ngModel) 지시자는 폼 엘리먼트가 양방향 바인딩을 가능하게 하는 가교 역할을 합니다.

  Fortunately, the Angular [_NgModel_](#ngModel) directive is a bridge that enables two-way binding to form elements.

a#ngModel
.l-main-section
:marked
  ## NgModel을 사용한 양방향 바인딩
  ## Two-way binding with NgModel
  데이터 입력 폼을 개발할 때, 종종 데이터 프로퍼티를 보여주고 사용자가 변경을 하면 그 프로퍼티를 업데이트 하기를 원합니다.

  When developing data entry forms, we often want to both display a data property and update that property when the user makes changes.

  `NgModel` 지시자를 사용한 양방향 데이터 바인딩은 이것을 쉽게 해줍니다. 다음은 그 예입니다:

  Two-way data binding with the `NgModel` directive makes that easy. Here's an example:
+makeExcerpt('app/app.component.html', 'NgModel-1', '')

+ifDocsFor('ts|js')
  .callout.is-important
    header ngModel을 사용하려면 FormsModule이 필요합니다.
    header FormsModule is Required to use ngModel
    :marked
      양방향 데이터 바인딩에서 `ngModel` 지시자를 사용하기 전에,
      `FormsModule`을 임포트해야 하고 Angular 모듈의 `imports` 목록에 추가해야합니다.
      `FormsModule` 과 `ngModel`에 대해
      [폼](../guide/forms.html#ngModel) 챕터에서 더 자세히 알아보세요.

      Before we can use the `ngModel` directive in a two-way data binding,
      we must import the `FormsModule` and add it to the Angular module's `imports` list.
      Learn more about the `FormsModule` and `ngModel` in the
      [Forms](../guide/forms.html#ngModel) chapter.
  :marked
    다음은 `[(ngModel)]`을 가능하게 하는 `FormsModule`을 임포트 하는 방법입니다.

    Here's how to import the `FormsModule` to make `[(ngModel)]` available.
  +makeExcerpt('app/app.module.1.ts (FormsModule import)', '')

:marked
  ### `[(ngModel)]` 내부
  ### Inside `[(ngModel)]`
  `firstName` 바인딩을 되돌아 보면 `<input>` 엘리먼트의 `value` 프로퍼티와
  `input` 이벤트에 각각 바인딩하여 같은 결과를 얻을 수 있다는 것을 
  기억하는 것이 중요합니다.

  Looking back at the `firstName` binding, it's important to note that
  we could have achieved the same result with separate bindings to
  the `<input>` element's  `value` property and `input` event.
+makeExample('template-syntax/ts/app/app.component.html', 'without-NgModel')(format=".")
:marked
  성가신 일이군요. 어떤 엘리먼트 프로퍼티를 설정해야 하고 어떤 엘리먼트 이벤트가 사용자 변경사항을 방출하는지 누가 기억할 수 있을까요?
  어떻게 입력 상자에서 현재 표시된 텍스트를 가져와서 데이터 프로퍼티를 업데이트 할 수 있을까요?
  누가 매번 그걸 살펴보길 원할까요?

  That’s cumbersome. Who can remember which element property to set and which element event emits user changes?
  How do we extract the currently displayed text from the input box so we can update the data property?
  Who wants to look that up each time?

  `ngModel` 지시자는 자체의 `ngModel` 인풋과 `ngModelChange` 아웃풋 프로퍼티 뒤에 이러한 번거로운 세부사항을 숨깁니다.

  That `ngModel` directive hides these onerous details behind its own  `ngModel` input and `ngModelChange` output properties.
+makeExample('template-syntax/ts/app/app.component.html', 'NgModel-3')(format=".")
.l-sub-section
  :marked
    `ngModel` 데이터 프로퍼티는 엘리먼트의 값 프로퍼티를 설정하고 `ngModelChange` 이벤트 프로퍼티는
    엘리먼트 값의 변경사항을 듣고 있습니다.    

    The `ngModel` data property sets the element's value property and the `ngModelChange` event property
    listens for changes to the element's value.
    
    세부사항은 각각의 엘리먼트 종류에 따라 다르므로 `NgModel` 지시자는, 
    [ControlValueAccessor](../api/forms/index/ControlValueAccessor-interface.html)에서 지원하는 입력 텍스트 상자와 같은, 오직 특정 폼 엘리먼트에만 작동합니다.

    The details are specific to each kind of element and therefore the `NgModel` directive only works for specific form elements,
    such as the input text box, that are supported by a [ControlValueAccessor](../api/forms/index/ControlValueAccessor-interface.html).

    이번 챕터의 범위를 벗어나는 기술인 *값 접근자(value accessor)*를 작성하지 않는 이상 `[(ngModel)]`을 커스텀 컴포넌트에 적용할 수는 없습니다.
    이것은 제어할 수 없는 API를 가진 Angular 컴포넌트나 WebComponent에 대해 하고자 하는 작업일 것입니다.

    We can't apply `[(ngModel)]` to a custom component until we write a suitable *value accessor*,
    a technique that is beyond the scope of this chapter.
    That's something we might want to do for an Angular component or a WebComponent whose API we can't control.
    
    _제어_ 가능한 Angular 컴포넌트에게는 전혀 필요없는 일입니다 ... 왜냐하면 
    Angular의 기본 [양방향 바인딩 구문](#two-way)에 적합하도록 값과 이벤트 프로퍼티의 이름을 정하여 완전히 `NgModel`을 건너뛸수 있기 때문입니다.

    It's completely unnecessary for an Angular component that we _do_ control ... because we can name the value and event properties
    to suit Angular's basic [two-way binding syntax](#two-way) and skip `NgModel` altogether.

:marked
  분리된 `ngModel` 바인딩은 엘리먼트의 네이티브 프로퍼티에 바인딩하는 것 보다 개선된 기능입니다. 더 개선할 수 있습니다.

  Separate `ngModel` bindings is an improvement over binding to the element's native properties. We can do better.

  데이터 프로퍼티를 두번 언급하지 않아도 됩니다. Angular는 컴포넌트의 데이터 프로퍼티를 캡쳐하여
  단일 선언으로 설정할 수 있어야 합니다. 이것은 `[(ngModel)]` 구문으로 할 수 있습니다.

  We shouldn't have to mention the data property twice. Angular should be able to capture the component’s data property and set it
  with a single declaration &mdash; which it can with the `[(ngModel)]` syntax:
+makeExample('template-syntax/ts/app/app.component.html', 'NgModel-1')(format=".")
:marked
  우리가 필요한 것은 `[(ngModel)]`이 전부일까요? 확장된 형태로 돌아가야할 이유가 있기는 할까요?

  Is `[(ngModel)]` all we need? Is there ever a reason to fall back to its expanded form?

  `[(ngModel)]` 구문은 오직 데이터형(data-bound) 프로퍼티를 _설정_할 수 있습니다.
  만약 무엇인가 더 필요하거나 무엇인가 다른게 필요하다면, 우리 스스로 확장된 형태로 작성해야 합니다.

  The `[(ngModel)]` syntax can only _set_ a data-bound property.
  If we need to do something more or something different, we need to write the expanded form ourselves.

  입력 값을 대문자로 강제하는 것과 같은 간단한 것을 해보겠습니다:

  Let's try something silly like forcing the input value to uppercase:
+makeExample('template-syntax/ts/app/app.component.html', 'NgModel-4')(format=".")
:marked
  여기에는 uppercase를 사용한 버전을 포함하여 다양한 버전이 있습니다.

  Here are all variations in action, including the uppercase version:
figure.image-display
    img(src='/resources/images/devguide/template-syntax/ng-model-anim.gif' alt="NgModel variations")

.l-main-section
:marked
  <a id="directives"></a>
  ## 내장 지시자
  ## Built-in directives

  Angular의 초기 버전은 70개 이상의 내장 지시자가 포함되어 있었습니다.
  커뮤니티는 더 많은 기여를 했으며, 내부 애플리케이션에 사용되는
  무수히 많은 private 지시자가 생성되었습니다.

  Earlier versions of Angular included over seventy built-in directives.
  The community contributed many more, and countless private directives
  have been created for internal applications.

  Angular 개발에 이러한 지시자가 많이 필요하지는 않습니다.
  상당 부분은 보다 기능적이고 표현력 있는 Angular 바인딩 시스템으로 동일한 결과를 얻을 수 있습니다.
  왜 다음과 같은 간단한 바인딩을 작성할 때 클릭 처리 지시자를 만들까요?

  We don’t need many of those directives in Angular.
  Quite often we can achieve the same results with the more capable and expressive Angular binding system.
  Why create a directive to handle a click when we can write a simple binding such as this?
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-1')(format=".")
:marked
  복잡한 작업을 간략화하는 지시자로부터 혜택을 볼 수 있습니다.
  Angular는 그렇게 많지는 않지만 여전히 내장 지시자를 배포하고 있습니다.
  우리 자신만의 지시자를 몇개 만들어 보겠습니다.

  We still benefit from directives that simplify complex tasks.
  Angular still ships with built-in directives; just not as many.
  We'll write our own directives, just not as many.

  이 세그먼트에서는 가장 자주 사용되는 내장 지시자를 살펴보겠습니다.

  This segment reviews some of the most frequently used built-in directives.

<a id="ngClass"></a>
.l-main-section
:marked
  ### NgClass
  ### NgClass

  우리는 일반적으로 CSS 클래스를 동적으로 추가하거나 제거하여
  엘리먼트가 보이는 것을 제어합니다.
  `NgClass`에 바인딩하여 동시에 여러 클래스를 추가하거나 제거할 수 있습니다.

  We typically control how elements appear
  by adding and removing CSS classes dynamically.
  We can bind to `NgClass` to add or remove several classes simultaneously.

  [클래스 바인딩](#class-binding)은 *단일* 클래스를 추가하거나 제거하기 위해 좋은 방법입니다.

  A [class binding](#class-binding) is a good way to add or remove a *single* class.
+makeExample('template-syntax/ts/app/app.component.html', 'class-binding-3a')(format=".")
:marked
  *많은* CSS 클래스를 동시에 추가하거나 제거하는 경우
  `NgClass` 지시자가 좀 더 좋은 선택입니다.

  The `NgClass` directive may be the better choice
  when we want to add or remove *many* CSS classes at the same time.

  `NgClass`를 적용하는 좋은 방법은 key:value 제어 !{__objectAsMap_ko}에 바인딩하는 것입니다.
  각 객체의 키는 CSS 클래스 이름입니다; 그것의 값은 클래스가 추가되어야 할 경우 `true`,
  제거되어야 할 경우 `false`가 됩니다.

  A good way to apply `NgClass` is by binding it to a key:value control !{__objectAsMap}. 
  Each key of the object is a CSS class name; its value is `true` if the class should be added, 
  `false` if it should be removed.

:marked
  컴포넌트 프로퍼티 `currentClasses` 객체를 설정하는 컴포넌트 메소드 `setCurrentClasses`를 생각해보겠습니다.
  이것은 3개의 다른 컴포넌트 프로퍼티의 `true`/`false` 상태에 따라
  3개의 클래스를 추가하거나 제거합니다.

  Consider a 
  `setCurrentClasses` component method that sets a component property, `currentClasses`
  with an object that adds or removes three classes based on the 
  `true`/`false` state of three other component propertes:
+makeExample('template-syntax/ts/app/app.component.ts', 'setClasses')(format=".")
:marked
  다음과 같이 `NgClass` 프로퍼티 바인딩을 추가하여 `currentClasses`가 엘리먼트의 클래스를 설정하도록 하세요:

  Adding an `NgClass` property binding to `currentClasses` sets the element's classes accordingly:  
+makeExample('template-syntax/ts/app/app.component.html', 'NgClass-1')(format=".")
.l-sub-section
  :marked
    종속되는 프로퍼티가 변경되거나 초기화 할 때, `setCurrentClasses()`를 호출하는 것은 여러분에게 달려있습니다.

    It's up to you to call `setCurrentClassess()`, both initially and when the dependent properties change.

<a id="ngStyle"></a>
.l-main-section
:marked
  ### NgStyle
  ### NgStyle
  우리는 컴포넌트의 상태에 따라 동적으로 인라인 스타일을 설정할 수 있습니다.
  `NgStyle`에 바인딩하여 많은 인라인 스타일을 동시에 설정할 수 있습니다.

  We can set inline styles dynamically, based on the state of the component.
  Binding to `NgStyle` lets us set many inline styles simultaneously.

  [스타일 바인딩](#style-binding)은 *단일* 스타일 값을 설정하는 간단한 방법입니다.

  A [style binding](#style-binding) is an easy way to set a *single* style value.
+makeExample('template-syntax/ts/app/app.component.html', 'NgStyle-1')(format=".")
:marked
  *많은* CSS 인라인 스타일을 동시에 추가하거나 제거하는 경우
  `NgStyle` 지시자가 좀 더 좋은 선택입니다.

  The `NgStyle` directive may be the better choice
  when we want to set *many* inline styles at the same time.

  `NgStyle`을 적용하는 좋은 방법은 key:value 제어 !{__objectAsMap_ko}에 바인딩하는 것입니다.
  각 객체의 키는 스타일 이름입니다; 그것의 값은 해당 스타일에 적합한 어떤 것입니다.

  We apply `NgStyle` by binding it to a key:value control !{__objectAsMap}.
  Each key of the object is a style name; its value is whatever is appropriate for that style.

  컴포넌트 프로퍼티 `currentStyles` 객체를 설정하는 컴포넌트 메소드 `setCurrentStyles`를 생각해보겠습니다.
  이것은 3개의 다른 컴포넌트 프로퍼티의 상태에 따라 3개의 스타일을 추가하거나 제거합니다.

  Consider a `setCurrentStyles` component method that sets a component property, `currentStyles`
  with an object that defines three styles, based on the state of three other component propertes:
+makeExample('template-syntax/ts/app/app.component.ts', 'setStyles')(format=".")
:marked
  다음과 같이 `NgStyle` 프로퍼티 바인딩을 추가하여 `currentStyles`가 엘리먼트의 스타일을 설정하도록 하세요:

  Adding an `NgStyle` property binding to `currentStyles` sets the element's styles accordingly:
+makeExample('template-syntax/ts/app/app.component.html', 'NgStyle-2')(format=".")
.l-sub-section
  :marked
    종속되는 프로퍼티가 변경되거나 초기화 할 때, `setCurrentStyles()`를 호출하는 것은 여러분에게 달려있습니다.

    It's up to you to call `setCurrentStyles()`, both initially and when the dependent properties change.

<a id="ngIf"></a>
.l-main-section
:marked
  ### NgIf
  ### NgIf
  `NgIf` 지시자를 #{_truthy_ko}인 표현식에 바인딩하여 DOM에 엘리먼트 하위트리(엘리먼트와 그 자식들)를 추가할 수 있습니다.

  We can add an element subtree (an element and its children) to the DOM  by binding an `NgIf` directive to a #{_truthy} expression.
+makeExample('template-syntax/ts/app/app.component.html', 'NgIf-1')(format=".")

.alert.is-critical
  :marked
    `ngIf` 앞에 별표 (`*`)를 잊지 마세요.
    보다 자세한 내용은 [\* 와 &lt;template>](#star-template)에서 확인하세요.

    Don't forget the asterisk (`*`) in front of `ngIf`.
    For more information, see [\* and &lt;template>](#star-template).
:marked
  #{_falsey_ko}인 표현식에 바인딩하면 DOM에서 엘리먼트 하위트리를 제거합니다.

  Binding to a #{_falsey} expression removes the element subtree from the DOM.
+makeExample('template-syntax/ts/app/app.component.html', 'NgIf-2')(format=".")

block dart-no-truthy-falsey
  //- N/A

:marked
  #### Visibility와 NgIf는 다릅니다.
  #### Visibility and NgIf are not the same

  [클래스](#class-binding) 또는 [스타일](#style-binding) 바인딩으로
  엘리먼트 하위트리(엘리먼트와 그 자식들)을 보이거나 숨길 수 있습니다:

  We can show and hide an element subtree (the element and its children) with a
  [class](#class-binding) or [style](#style-binding) binding:
+makeExample('template-syntax/ts/app/app.component.html', 'NgIf-3')(format=".")
:marked
  하위트리를 숨기는 것은 `NgIf`로 하위트리를 제외하는 것과는 다릅니다.

  Hiding a subtree is quite different from excluding a subtree with `NgIf`.

  엘리먼트 하위트리를 숨겨도 DOM에는 남아있습니다.
  하위트리의 컴포넌트들은 그들의 상태정보와 함께 보존됩니다.
  Angular는 숨겨진 프로퍼티에 대해서도 지속적으로 변경사항을 확인합니다.
  하위트리는 상당한 메모리와 컴퓨팅 자원을 차지할 수 있습니다.

  When we hide the element subtree, it remains in the DOM.
  Components in the subtree are preserved, along with their state.
  Angular may continue to check for changes even to invisible properties.
  The subtree may tie up substantial memory and computing resources.

  `NgIf`가 `false`인 경우, Angular는 DOM에서 하위트리를 물리적으로 제거합니다.
  하위트리에서 상태와 함께 컴포넌트를 파괴하고, 상당한 자원을 확보하여
  사용자에게 더 나은 성능을 제공합니다.

  When `NgIf` is `false`, Angular physically removes the element subtree from the DOM.
  It destroys components in the subtree, along with their state, potentially freeing up substantial resources and
  resulting in better performance for the user.

  표시/숨기기 기술을 작은 엘리먼트 트리에 사용할 때는 괜찮을 수 있습니다.
  큰 트리를 숨길때는 조심해야 합니다; `NgIf`가 보다 안전한 선택일 수 있습니다. 항상 결론을 내기 전에 검증해보세요.

  The show/hide technique is probably fine for small element trees.
  We should be wary when hiding large trees; `NgIf` may be the safer choice. Always measure before leaping to conclusions.

<a id="ngSwitch"></a>
.l-main-section
:marked
  ### NgSwitch
  ### NgSwitch
  어떤 조건에 따라 가능한 엘리먼트 트리의 *세트*에서 *하나*의 엘리먼트 트리(엘리먼트와 그 자식들)를
  표시하려고 한다면 `NgSwitch`에 바인딩하세요.
  Angular는 DOM에 오직 *선택된* 엘리먼트 트리만 표시합니다.

  We bind to `NgSwitch` when we want to display *one* element tree (an element and its children)
  from a *set* of possible element trees, based on some condition.
  Angular puts only the *selected* element tree into the DOM.

  다음은 그 예입니다:

  Here’s an example:
+makeExample('template-syntax/ts/app/app.component.html', 'NgSwitch')(format=".")
:marked
  부모 `NgSwitch` 지시자를 *switch 값*을 반환하는 표현식에 바인딩합니다.
  이번 예제에서 값은 문자열입니다, 그러나 값은 어느 타입이라도 가능합니다.

  We bind the parent `NgSwitch` directive to an expression returning a *switch value*.
  The value is a string in this example, but it can be a value of any type.

  이번 예제에서, 부모 `NgSwitch` 지시자는 자식 `<span>` 엘리먼트를 제어합니다.
  `<span>`은 *일치하는 값* 표현식 또는 기본 값으로 정해집니다.

  In this example, the parent `NgSwitch` directive controls a set of child `<span>` elements.
  A `<span>` is either pegged to a *match value* expression or marked as the default.

  **특정 시점에 이 *span*들 중에 하나만 DOM 안에 있게 됩니다.**

  **At any particular moment, at most one of these *spans* is in the DOM.**

  만약 *span*의 *일치하는 값*이 switch 값과 같으면, Angular는 `<span>`을 DOM에 추가합니다.
  만약 *span* 중에 일치하는 값이 없다면, Angular는 기본 *span*을 DOM에 추가합니다.
  Angular는 다른 모든 *span*을 제거하고 파괴합니다.

  If the *span*’s *match value* equals the switch value, Angular adds the `<span>` to the DOM.
  If none of the *spans* is a match, Angular adds the default *span* to the DOM.
  Angular removes and destroys all other *spans*.
.l-sub-section
  :marked
    이번 예제의 *span*은 어떤 엘리먼트로도 교체 가능합니다.
    그 엘리먼트는 커다란 하위트리를 가진 `<div>`가 될 수 있습니다.
    오직 일치하는 `<div>`와 그 하위트리만 DOM에 보이게 됩니다;
    다른 것들은 제거됩니다.

    We could substitute any element for the *span* in this example.
    That element could be a `<div>` with a vast subtree of its own elements.
    Only the matching `<div>` and its subtree would appear in the DOM;
    the others would be removed.
:marked
  여기서 세 가지의 협력 지시자가 동작하고 있습니다:

  Three collaborating directives are at work here:

  1. `ngSwitch`: switch 값을 반환하는 표현식에 바인딩

  1. `ngSwitch`: bound to an expression that returns the switch value

  1. `ngSwitchCase`: 일치하는 값을 반환하는 표현식에 바인딩

  1. `ngSwitchCase`: bound to an expression returning a match value

  1. `ngSwitchDefault`: 기본 엘리먼트 속성 표시자

  1. `ngSwitchDefault`: a marker attribute on the default element

.alert.is-critical
  :marked
    `ngSwitch` 앞에 별표 (`*`)를 사용하면 ***안* 됩니다**. 대신에 프로퍼티 바인딩을 사용하세요.

    **Do *not*** put the asterisk (`*`) in front of `ngSwitch`. Use the property binding instead.

    `ngSwitchCase`와 `ngSwitchDefault` 앞에 별표 (`*`)를 **붙이세요**.
    [\* 와 &lt;template>](#star-template)에서 자세히 알아보세요.

    **Do** put the asterisk (`*`) in front of `ngSwitchCase` and `ngSwitchDefault`.
    For more information, see [\* and &lt;template>](#star-template).

<a id="ngFor"></a>
.l-main-section
:marked
  ### NgFor
  ### NgFor

  `NgFor`는 지시자 _반복기_ 입니다 &mdash;데이터 표시를 사용자 정의하는 방법.

  `NgFor` is a _repeater_ directive &mdash; a way to customize data display.

  우리의 목표는 아이템 목록을 표시하는 것입니다. 단일 아이템이 어떻게 보여야 하는지를 정의하는 HTML 블록을 정의합니다.
  그리고 Angular에게 목록의 각 아이템을 렌더링하는 템플릿으로 해당 블록을 사용하라고 알려줍니다.

  Our goal is to present a list of items. We define a block of HTML that defines how a single item should be displayed.
  We tell Angular to use that block as a template for rendering each item in the list.

  다음은 간단한 `<div>`에 적용된 `NgFor`의 예제입니다:

  Here is an example of `NgFor` applied to a simple `<div>`:
+makeExample('template-syntax/ts/app/app.component.html', 'NgFor-1')(format=".")
:marked
  또한 다음 예제처럼 컴포넌트 엘리먼트에 `NgFor`를 적용할 수도 있습니다:
  
  We can also apply an `NgFor` to a component element, as in this example:
+makeExample('template-syntax/ts/app/app.component.html', 'NgFor-2')(format=".")

.alert.is-critical
  :marked
    `ngFor` 앞의 별표 (`*`)를 잊지 마세요.
    [\* 와 &lt;template>](#star-template)에서 자세한 내용을 확인하세요.

    Don't forget the asterisk (`*`) in front of `ngFor`.
    For more information, see [\* and &lt;template>](#star-template).
:marked
  `*ngFor`에 할당된 텍스트는 반복기 프로세스를 안내하는 명령문입니다.

  The text assigned to `*ngFor` is the instruction that guides the repeater process.

<a id="ngForMicrosyntax"></a>
:marked
  #### NgFor 세부구문(microsyntax)
  #### NgFor microsyntax
  `*ngFor`에 할당된 문자열은 [템플릿 표현식](#template-expressions)이 아닙니다.
  그것은 *세부구문(microsyntax)* &mdash; Angular가 해석하는 자체의 작은 언어입니다. 이번 예제에서 `"let hero of heroes"` 문자열은 다음을 뜻합니다:

  The string assigned to `*ngFor` is not a [template expression](#template-expressions).
  It’s a *microsyntax* &mdash; a little language of its own that Angular interprets. In this example, the string `"let hero of heroes"` means:

  > *`heroes` #{_array_ko}에서 각각의 히어로를 가져와서 로컬 `hero` 변수에 저장하여 각 반복 템플릿 HTML에서 사용할 수 있도록하라.*

  > *Take each hero in the `heroes` #{_array}, store it in the local `hero` variable, and make it available to the templated HTML for each iteration.*

  Angular는 이 명령을 새로운 엘리먼트와 바인딩 세트로 번역합니다.

  Angular translates this instruction into a new set of elements and bindings.

  앞의 2개의 예에서, `ngFor` 지시자는 부모 컴포넌트의 
  `heroes` 프로퍼티에 의해 반환된 `heroes` #{_array_ko}을 반복하고, 
  적용된 변수에 엘리먼트의 인스턴스를 찍어냅니다.
  Angular는 배열의 각 히어로에 대해 새로운 템플릿 인스턴스를 생성합니다.

  In the two previous examples, the `ngFor` directive iterates over the `heroes` #{_array} returned by the parent component’s `heroes` property,
  stamping out instances of the element to which it is applied.
  Angular creates a fresh instance of the template for each hero in the array.

  `hero` 앞의 `let` 키워드는 `hero`라는 템플릿 입력 변수를 생성합니다.

  The `let` keyword before `hero` creates a template input variable called `hero`.

.alert.is-critical
  :marked
     템플릿 입력 변수는 [템플릿 참조 변수](#ref-vars)와 **다릅니다**!

     A template input variable is **not** the same as a [template reference variable](#ref-vars)!

:marked
  삽입식에서 한 것처럼 템플릿에서 히어로의 프로퍼티에 접근하기 위해
  이 변수를 사용합니다.
  또한 `hero-detail`에서 한 것처럼 바인딩의 변수를
  컴포넌트 엘리먼트에 전달할 수도 있습니다.

  We use this variable within the template to access a hero’s properties,
  as we’re doing in the interpolation.
  We can also pass the variable in a binding to a component element,
  as we're doing with `hero-detail`.

:marked
  #### NgFor 인덱스
  #### NgFor with index
  `ngFor` 지시자는 각 반복에서 0부터 배열의 길이만큼 증가하는 선택적 `index`를 지원합니다.
  템플릿 입력 변수에 인덱스를 가져와 템플릿에서 사용할 수 있습니다.

  The `ngFor` directive supports an optional `index` that increases from 0 to the length of the array for each iteration.
  We can capture the index in a template input variable and use it in our template.

  다음 예제는 `i` 변수에 인덱스를 가져와서, "1 - Hercules Son of Zeus" 처럼 열을 출력하는데 사용합니다.

  The next example captures the index in a variable named `i`, using it to stamp out rows like "1 - Hercules Son of Zeus".
+makeExample('template-syntax/ts/app/app.component.html', 'NgFor-3')(format=".")
.l-sub-section
  :marked
    [NgFor API 참조설명](../api/common/index/NgFor-directive.html)에서 
    `last`, `even`, `odd`와 같은 특별한 *인덱스 비슷한* 값에 대해 알아보세요.

    Learn about other special *index-like* values such as `last`, `even`, and `odd` in the [NgFor API reference](../api/common/index/NgFor-directive.html).

:marked
  #### NgForTrackBy
  #### NgForTrackBy
  잠재적으로 `ngFor` 지시자는 특히 큰 목록에 대해 느리게 동작할 수 있습니다.
  아이템 삭제나 아이템 추가와 같은 하나의 아이템에 대한 작은 변화가 중첩적인 DOM 처리를 유발할 수 있습니다.

  The `ngFor` directive has the potential to perform poorly, especially with large lists.
  A small change to one item, an item removed, or an item added can trigger a cascade of DOM manipulations.

  예를 들어, 서버에 재조회를 하여 히어로 목록을 새로고침할 수 있습니다.
  새로운 목록은 아마도 앞서 표시한 히어로의 전부는 아니라도 대부분을 보유하고 있을 것입니다.

  For example, we could refresh the list of heroes by re-querying the server.
  The refreshed list probably contains most, if not all, of the previously displayed heroes.

  *우리는* 각 히어로의 `id`가 변경되지 않았기 때문에 이것을 알 수 있습니다.
  그러나 Angular는 새로운 객체 참조의 새로운 목록만을 알고 있습니다.
  이전 목록을 폐기하고, 해당 DOM 요소를 버리고, 새로운 DOM 요소로 새 목록을 다시 작성할 수밖에 없습니다.

  *We* know this because the `id` of each hero hasn't changed.
  But Angular sees only a fresh list of new object references.
  It has no choice but to tear down the old list, discard those DOM elements, and re-build a new list with new DOM elements.

  Angular에게 `hero.id`가 같은 객체는 같은 *히어로*라는 것을 알려주는 
  *tracking* 함수를 제공하여 이러한 혼란을 피할 수 있습니다. 다음은 이러한 함수입니다.

  Angular can avoid this churn if we give it a *tracking* function that tells it what we know:
  that two objects with the same `hero.id` are the same *hero*. Here is such a function:
+makeExample('template-syntax/ts/app/app.component.ts', 'trackByHeroes')(format=".")
:marked
  이제 해당 *tracking` 함수에 `NgForTrackBy` 지시자를 설정합니다.

  Now set the `NgForTrackBy` directive to that *tracking* function.
+makeExample('template-syntax/ts/app/app.component.html', 'NgForTrackBy-2')(format=".")
:marked
  *tracking* 함수는 모든 DOM 변경을 제거하지 않습니다.
  만약 같은 히어로의 *프로퍼티*가 변경되면, Angular는 DOM 엘리먼트를 업데이트해야 합니다.
  그러나 만약 프로퍼티가 변경되지 않았다면 &mdash; 그리고 대부분 변경되지 않을 것이라면 &mdash;
  Angular는 이러한 DOM 엘리먼트를 내버려둘 수 있습니다. 리스트 UI는 보다 부드럽고 반응적이 될 것입니다.

  The *tracking* function doesn't eliminate all DOM changes.
  Angular may have to update the DOM element if the same-hero *properties* have changed.
  But if the properties haven't changed &mdash; and most of the time they will not have changed &mdash;
  Angular can leave those DOM elements alone. The list UI will be smoother and more responsive.

  다음은 `NgForTrackBy`의 효과를 설명합니다.

  Here is an illustration of the `NgForTrackBy` effect.
figure.image-display
  img(src='/resources/images/devguide/template-syntax/ng-for-track-by-anim.gif' alt="NgForTrackBy")

<a id="star-template"></a>
<a id="structural-directive"></a>
.l-main-section
:marked
  ## * 와 &lt;template&gt;
  ## * and &lt;template&gt;
  `NgFor`, `NgIf`와 `NgSwitch` 내장 지시자를 다시 살펴보면, 지시자 이름 앞에 별표 (`*`)와 같은 이상한 문법을 호출하고 있습니다.

  When we reviewed the `NgFor`, `NgIf`, and `NgSwitch` built-in directives, we called out an oddity of the syntax: the asterisk (`*`) that appears before the directive names.

  `*`는 템플릿을 사용하여 HTML 레이아웃을 수정하는 지시자를 읽고 쓰기 쉽도록 해주는 간편 표기법(syntactic sugar)입니다.
  `NgFor`, `NgIf`, 및 `NgSwitch` 모두 `<template>` 태그로 둘러싸인 엘리먼트 하위트리를 추가하거나 제거합니다.
  
  The `*` is a bit of syntactic sugar that makes it easier to read and write directives that modify HTML layout
  with the help of templates.
  `NgFor`, `NgIf`, and `NgSwitch` all add and remove element subtrees that are wrapped in `<template>` tags.

  `<template>` 태그는 보지 못했습니다. 왜냐하면 `*` 접두어는 이러한 태그를 건너뛰고
  우리가 포함하고 제외하고 반복하는 HTML 엘리먼트에 직접 집중하도록 해주기 때문입니다.

  We didn't see the `<template>` tags because the `*` prefix syntax allowed us to skip those tags and
  focus directly on the HTML element that we are including, excluding, or repeating.

  이번 섹션에서는 내부로 들어가 Angular가 어떻게 `*`를 제거하고
  HTML을 `<template>` 태그로 확장했는지 살펴보았습니다.

  In this section we go under the hood and see how
  Angular strips away the `*` and expands the HTML into the `<template>` tags for us.

:marked
  ### `*ngIf` 확장
  ### Expanding `*ngIf`
  Angular가 하는 것을 직접 처리하여 `*` 접두어 구문을 템플릿 구문으로 확장할 수 있습니다.

  We can do what Angular does ourselves and expand the `*` prefix syntax to template syntax. Here's some code with `*ngIf`:
+makeExample('template-syntax/ts/app/app.component.html', 'Template-1')(format=".")
:marked
  `currentHero`는 두번 참조됩니다. 처음은 `NgIf`의 true/false 조건으로서,
  다음은 `HeroDetailComponent`에 전달되는 실제 히어로로서 입니다.

  The `currentHero` is referenced twice, first as the true/false condition for `NgIf` and
  again as the actual hero passed into the `HeroDetailComponent`.

  처음 확장 단계는 `ngIf` (`*` 접두어 없이)와 해당 컨텐츠를 `template` 지시자에
  할당된 표현식으로 전송합니다.

  The first expansion step transports the `ngIf` (without the `*` prefix) and its contents
  into an expression assigned to a `template` directive.
+makeExample('template-syntax/ts/app/app.component.html', 'Template-2a')(format=".")
:marked
  다음이자 마지막 단계는 HTML을 `<template>` 태그와 `[ngIf]` [프로퍼티 바인딩](#property-binding)에 푸는 것입니다.

  The next (and final) step unfolds the HTML into a `<template>` tag and `[ngIf]` [property binding](#property-binding):
+makeExample('template-syntax/ts/app/app.component.html', 'Template-2')(format=".")
:marked
  `[hero]="currentHero"` 바인딩은 템플릿 안의 자식 `<hero-detail>` 엘리먼트에 
  남아있다는 것에 유의하세요.

  Notice that the `[hero]="currentHero"` binding remains on the child `<hero-detail>`
  element inside the template.

block remember-the-brackets
  .callout.is-critical
    header 대괄호를 기억하세요!
    header Remember the brackets!
    :marked
      `ngIf="currentHero"`로 작성하는 실수를 하지 마세요!
      이 구문은 `ngIf`에 *문자열* 값인 `"currentHero"`를 할당합니다.
      JavaScript에서 비어있지 않은 문자열은 참인 값입니다. 그러므로 `ngIf`는
      항상 `true`이고 Angular는 항상 `hero-detail`을 표시할 것입니다.
      … 심지어 `currentHero`가 없을 경우에도요!

      Don’t make the mistake of writing `ngIf="currentHero"`!
      That syntax assigns the *string* value `"currentHero"` to `ngIf`.
      In JavaScript a non-empty string is a truthy value, so `ngIf` would always be
      `true` and Angular would always display the `hero-detail`
      … even when there is no `currentHero`!

:marked
  ### `*ngSwitch` 확장
  ### Expanding `*ngSwitch`
  비슷한 변환을 `*ngSwitch`에도 적용할 수 있습니다. 구문을 우리 스스로 풀 수 있습니다.
  아래 예는, 처음에는 `*ngSwitchCase`와 `*ngSwitchDefault`를 사용하고 다음에는 `<template>` 태그를 사용했습니다.

  A similar transformation applies to `*ngSwitch`. We can unfold the syntax ourselves.
  Here's an example, first with `*ngSwitchCase` and `*ngSwitchDefault` and then again with `<template>` tags:
+makeExample('template-syntax/ts/app/app.component.html', 'NgSwitch-expanded')(format=".")
:marked
  `*ngSwitchCase`와 `*ngSwitchDefault` 확장은 `*ngIf`와 정확히 동일한 방식으로 확장합니다.
  앞의 엘리먼트를 `<template>` 태그로 감싸고 있습니다.

  The `*ngSwitchCase` and `*ngSwitchDefault` expand in exactly the same manner as `*ngIf`,
  wrapping their former elements in `<template>` tags.

  이제 왜 `ngSwitch` 자체에는 별표 (*)를 접두어로 붙이지 않는지 이해했습니다.
  내용을 정의하는 것이 아닙니다. 그것의 역할은 템플릿 컬렉션을 제어하는 것입니다.

  Now we can see why the `ngSwitch` itself is not prefixed with an asterisk (*).
  It does not define content. It's job is to control a collection of templates.

  이번에는 `ngSwitchCase`와 `NgSwitchDefault` 지시자 2개의 세트를 관리합니다.
  선택된 템플릿의 값을 두번 표시할 것이라 기대합니다.
  한번은 (*) 접두어 버전이고 한번은 확장 템플릿 버전입니다.
  다음 예에서 정확히 확인할 수 있습니다:

  In this case, it governs two sets of `ngSwitchCase` and `NgSwitchDefault` directives.
  We should expect it to display the values of the selected template twice,
  once for the (*) prefixed version and once for the expanded template version.
  That's exactly what we see in this example:
figure.image-display
    img(src='/resources/images/devguide/template-syntax/ng-switch-anim.gif' alt="NgSwitch")
:marked
  ### `*ngFor` 확장
  ### Expanding `*ngFor`
  `*ngFor`는 비슷한 확장을 합니다. `*ngFor` 예로 시작하겠습니다:

  The `*ngFor` undergoes a similar transformation. We begin with an `*ngFor` example:
+makeExample('template-syntax/ts/app/app.component.html', 'Template-3a')(format=".")
:marked
  다음은 `ngFor`를 `template` 지시자로 옮긴 동일한 예입니다:

  Here's the same example after transporting the `ngFor` to the `template` directive:
+makeExample('template-syntax/ts/app/app.component.html', 'Template-3')(format=".")
:marked
  그리고 원래 `<hero-detail>` 엘리먼트를 포장한 `<template>` 태그로 좀 더 확장합니다.

  And here it is expanded further into a `<template>` tag wrapping the original `<hero-detail>` element:
+makeExample('template-syntax/ts/app/app.component.html', 'Template-4')(format=".")
:marked
  `NgFor` 코드는 `NgIf`보다 조금 더 복잡합니다. 왜냐하면 반복기는 보다 움직이는 부분을 가지고 있기 때문입니다.
  이 경우 목록을 확인하는 `NgForOf` 지시자와 `NgForTrackBy` 지시자를 생성하고 할당해야 합니다.
  `*ngFor` 구문을 사용하면 스스로 HTML을 확장하는 것보다 훨씬 작성하기가 쉽습니다.

  The `NgFor` code is a bit more complex than `NgIf` because a repeater has more moving parts to configure.
  In this case, we have to remember to create and assign the `NgForOf` directive that identifies the list and the `NgForTrackBy` directive.
  Using the `*ngFor` syntax is much easier than writing out this expanded HTML ourselves.

<a id="ref-vars"></a>
.l-main-section
:marked
  ## 템플릿 참조 변수
  ## Template reference variables

  **템플릿 참조 변수**는 DOM 엘리먼트나 템플릿 안에 있는 지시자의 참조입니다.

  A **template reference variable** is a reference to a DOM element or directive within a template.

  네이티브 DOM 엘리먼트에 사용될 수도 있지만 또한 Angular 컴포넌트에 사용될 수도 있습니다. &mdash; 사실, 이것은 임의의 커스텀 웹 컴포넌트에 대해서도 작동합니다.

  It can be used with native DOM elements but also with Angular components &mdash; in fact, it will work with any custom web component.

:marked
  ### 템플릿 참조 변수 참조
  ### Referencing a template reference variable

  템플릿 참조 변수는 현재 템플릿 _어느 곳에서나_ 사용할 수 있습니다.

  We can refer to a template reference variable _anywhere_ in the current template.
.l-sub-section
  :marked
    같은 템플릿에서 한번 이상 같은 변수명을 정의하지 마세요.
    런타임 값을 예측할 수 없게 됩니다.

    Do not define the same variable name more than once in the same template.
    The runtime value will be unpredictable.

:marked
  템플릿 참조 변수를 생성하고 사용하는 2개의 다른 예제가 있습니다:

  Here are two other examples of creating and consuming a Template reference variable:
+makeExample('template-syntax/ts/app/app.component.html', 'ref-phone')(format=".")
:marked
  "phone"의 해시 (`#`) 접두어는 `phone` 변수를 정의했음을 의미합니다.

  The hash (`#`) prefix to "phone" means that we're defining a `phone` variable.
.l-sub-section
  :marked
    `#` 문자 사용을 좋아하지 않는 사람은 정규 대안인
    `ref` 접두어를 사용할 수 있습니다. 예를 들어, `phone` 변수를
    `#phone`이나 `ref-phone`으로 선언할 수 있습니다.

    Folks who don't like using the `#` character can use its canonical alternative,
    the `ref-` prefix. For example, we can declare the our `phone` variable using
    either `#phone` or `ref-phone`.

:marked
  ### 변수가 값을 얻는 방법
  ### How a variable gets its value

  Angular는 변수의 값을 그것이 선언된 엘리먼트에 설정합니다.
  우리는 이러한 변수를 `input` 엘리먼트에 선언했습니다.
  해당 `input` 엘리먼트 객체를 버튼 엘리먼트에 전달했습니다.
  이것들은 이벤트 바인딩에서 `call` 메소드의 인자로 사용됩니다.

  Angular sets the variable's value to the element on which it was defined.
  We defined these variables on the `input` elements.
  We’re passing those `input` element objects across to the
  button elements, where they're used in arguments to the `call` methods in the event bindings.

:marked
  ### NgForm 과 템플릿 참조 변수
  ### NgForm and template reference variables
  마지막 예제 하나를 살펴보겠습니다: 템플릿 참조 변수의 전형인 폼입니다.

  Let's look at one final example: a form, the poster child for template reference variables.

  폼 HTML은 [폼](forms.html) 챕터에서 보았던 것처럼 매우 복잡할 수 있습니다.
  다음은 *간략화 한* 예제입니다. &mdash; 그리고 전혀 간단하지는 않습니다.

  The HTML for a form can be quite involved, as we saw in the [Forms](forms.html) chapter.
  The following is a *simplified* example &mdash; and it's not simple at all.
+makeExample('template-syntax/ts/app/app.component.html', 'ref-form')(format=".")
:marked
  이번 예제에서 템플릿 참조 변수 `theForm`은 HTML에서 3회나 보이고 있습니다.

  A template reference variable, `theForm`, appears three times in this example, separated
  by a large amount of HTML.
+makeExample('template-syntax/ts/app/app.component.html', 'ref-form-a')(format=".")
:marked
  `theForm`의 값은 무엇일까요?

  What is the value of `theForm`?

  만약 Angular가 처리하지 않았다면 아마도
  [HTMLFormElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement)일 것입니다.
  사실 이것은 네이티브 `HTMLFormElement`를 포장한 Angular의 내장 `NgForm` 지시자 `ngForm`입니다.
  그리고 이것에 사용자 입력의 유효성을 추적하는 능력과 같은 
  부가적인 슈퍼파워를 부여합니다.
  
  It would be the [HTMLFormElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement)
  if Angular hadn't taken it over.
  It's actually `ngForm`, a reference to the Angular built-in `NgForm` directive that wraps the native `HTMLFormElement`
  and endows it with additional superpowers such as the ability to
  track the validity of user input.

  이것은 우리가 어떻게 `theForm.form.valid`를 검사하여 submit 버튼을 비활성화 하고
  풍부한 정보를 가진 객체를 부모 컴포넌트의 `onSubmit` 메소드에 전달하는지 설명해줍니다.

  This explains how we can disable the submit button by checking `theForm.form.valid`
  and pass an object with rich information to the parent component's `onSubmit` method.

<a id="inputs-outputs"></a>
.l-main-section
:marked
  ## input과 output 프로퍼티
  ## Input and output properties
  아직까지는 주로 *바인딩 선언의 오른쪽*에 있는 
  템플릿 표현식과 명령문에 있는 컴포넌트 멤버에 바인딩하는 것에 초점을 맞췄습니다.
  이 위치에 있는 멤버는 데이터 바인딩 **소스**입니다.

  So far, we’ve focused mainly on binding to component members within template expressions and statements
  that appear on the *right side of the binding declaration*.
  A member in that position is a data binding **source**.

  이번 섹션에서는 *바인딩 선언의 왼쪽*에 있는 지시자 프로퍼티인
  **타겟**에 바인딩하는 것에 집중하겠습니다.
  이러한 지시자 프로퍼티는 반드시 **input**이나 **output**으로 선언되어야 합니다.

  This section concentrates on binding to **targets**, which are directive
  properties on the *left side of the binding declaration*.
  These directive properties must be declared as **inputs** or **outputs**.

.alert.is-important
  :marked
    모든 **컴포넌트**는 **지시자** 임을 기억하세요.

    Remember: All **components** are **directives**.
:marked
.l-sub-section
  :marked
    데이터 바인딩 **타겟**과 데이터 바인딩 **소스** 를 뚜렷하게 구별하고 있습니다.

    We're drawing a sharp distinction between a data binding **target** and a data binding **source**.

    바인딩 *타겟*은 `=`의 *왼쪽*에 있습니다.
    *소스*는 `=`의 *오른쪽*에 있습니다.

    The *target* of a binding is to the *left* of the `=`.
    The *source* is on the *right* of the `=`.

    바인딩 *타겟*은 `[]`, `()`, `[()]`와 같은 바인딩 구두점 안에 있는 프로퍼티나 이벤트입니다.
    *소스*는 따옴표 (`" "`)나 삽입식 (`{{}}`) 안에 있을 수 있습니다.

    The *target* of a binding is the property or event inside the binding punctuation: `[]`, `()` or `[()]`.
    The *source* is either inside quotes (`" "`) or within an interpolation (`{{}}`).

    **소스** 지시자의 모든 멤버는 자동으로 바인딩에 사용할 수 있습니다.
    템플릿 표현식이나 명령문 안의 지시자 멤버에 접근하기 위해 특별한 것을 할 필요는 없습니다.

    Every member of a **source** directive is automatically available for binding.
    We don't have to do anything special to access a directive member in a template expression or statement.

    **타겟** 지시자의 멤버에 *제한된* 접근을 할 수 있습니다.
    우리는 오직 *input*과 *output*으로 명시적으로 식별된 프로퍼티에만 바인딩할 수 있습니다.    

    We have *limited* access to members of a **target** directive.
    We can only bind to properties that are explicitly identified as *inputs* and *outputs*.
:marked
  다음 예에서 `iconUrl`과 `onSave`는 컴포넌트의 멤버로
  `=`의 오른쪽에 따옴표 된 구문안에서 참조됩니다.

  In the following example, `iconUrl` and `onSave` are members of a component
  that are referenced within quoted syntax to the right of the `=`.
+makeExample('template-syntax/ts/app/app.component.html', 'io-1')(format=".")
:marked
  이것들은 컴포넌트의 *input이나 output*이 아닙니다. 이것들은 바인딩의 데이터 소스입니다.

  They are *neither inputs nor outputs* of the component. They are data sources for their bindings.

  이제 *바인딩 타겟*일 경우의 `HeroDetailComponent`를 살펴보겠습니다.

  Now look at `HeroDetailComponent` when it is the **target of a binding**.
+makeExample('template-syntax/ts/app/app.component.html', 'io-2')(format=".")
:marked
  `HeroDetailComponent.hero`와 `HeroDetailComponent.deleteRequest`는 바인딩 선언의 **왼쪽**에 있습니다.
  `HeroDetailComponent.hero`는 대괄호 안에 있습니다; 이것은 프로퍼티 바인딩의 타겟입니다.
  `HeroDetailComponent.deleteRequest`는 소괄호 안에 있습니다; 이것은 이벤트 바인딩의 타겟입니다.

  Both `HeroDetailComponent.hero` and `HeroDetailComponent.deleteRequest` are on the **left side** of binding declarations.
  `HeroDetailComponent.hero` is inside brackets; it is the target of a property binding.
  `HeroDetailComponent.deleteRequest` is inside parentheses; it is the target of an event binding.

  ### input과 output 프로퍼티 선언하기
  ### Declaring input and output properties

  타겟 프로퍼티는 반드시 명시적으로 input이나 output으로 표기되어야 합니다.

  Target properties must be explicitly marked as inputs or outputs.

  `HeroDetailComponent` 내부를 살펴보면 이러한 프로퍼티들이 input과 output 프로퍼티
  데코레이터로 표기된 것을 볼 수 있습니다.

  When we peek inside `HeroDetailComponent`, we see that these properties are marked
  with decorators as input and output properties.
+makeExample('template-syntax/ts/app/hero-detail.component.ts', 'input-output-1')(format=".")

:marked
.l-sub-section
  :marked
    또는 다음 예제처럼 지시자 메타데이터의 `inputs` 과 `outputs` #{_array_ko}에
    멤버로 정의할 수 있습니다.

    Alternatively, we can identify members in the `inputs` and `outputs` #{_array}s
    of the directive metadata, as in this example:
  +makeExample('template-syntax/ts/app/hero-detail.component.ts', 'input-output-2')(format=".")
  <br>
  :marked
    input/output 프로퍼티를 데코레이터 또는 메타데이터 #{_array_ko} 중 한 가지 방식으로 정의할 수 있습니다.
    두 가지 방식을 모두 사용하면 안 됩니다!

    We can specify an input/output property either with a decorator or in a metadata #{_array}.
    Don't do both!
:marked
  ### Input or output?
  ### Input or output?

  *인풋* 프로퍼티는 일반적으로 데이터 값을 받습니다.
  *아웃풋* 프로퍼티는 `EventEmitter` 객체 같은 이벤트 생산자를 노출합니다.

  *Input* properties usually receive data values.
  *Output* properties expose event producers, such as `EventEmitter` objects.

  _input_과 _output_이라는 용어는 타겟 지시자의 관점을 반영합니다.

  The terms _input_ and _output_ reflect the perspective of the target directive.
figure.image-display
    img(src='/resources/images/devguide/template-syntax/input-output.png' alt="Inputs and outputs")
:marked
  `HeroDetailComponent.hero`는 `HeroDetailComponent` 관점에서 *input* 프로퍼티 입니다.
  왜냐하면 데이터가 템플릿 바인딩 표현식에서 해당 프로퍼티로 흘러 *들어가기* 때문입니다.

  `HeroDetailComponent.hero` is an **input** property from the perspective of `HeroDetailComponent`
  because data flows *into* that property from a template binding expression.

  `HeroDetailComponent.deleteRequest`은 `HeroDetailComponent` 관점에서 *output* 프로퍼티 입니다.
  왜냐하면 이벤트가 해당 프로퍼티에서 흘러 *나와서* 템플릿 바인딩 명령문의 핸들러를 향하기 때문입니다.

  `HeroDetailComponent.deleteRequest` is an **output** property from the perspective of `HeroDetailComponent`
  because events stream *out* of that property and toward the handler in a template binding statement.

h3#aliasing-io input/output 프로퍼티 별칭
h3#aliasing-io Aliasing input/output properties
:marked
  때로는 input/output 프로퍼티의 외부 이름이 내부 이름과 다르길 원할 때가 있습니다.

  Sometimes we want the public name of an input/output property to be different from the internal name.

  이것은 대부분 [속성 지시자](attribute-directives.html)인 경우입니다.
  지시자 소비자는 지시자의 이름에 바인딩하기를 기대합니다.
  예를 들어, `myClick` 셀렉터를 가진 지시자를 `<div>` 태그에 적용하려고 할때,
  `myClick` 이라는 이벤트 프로퍼티에 바인딩 되기를 원합니다.

  This is frequently the case with [attribute directives](attribute-directives.html).
  Directive consumers expect to bind to the name of the directive.
  For example, when we apply a directive with a `myClick` selector to a `<div>` tag,
  we expect to bind to an event property that is also called `myClick`.
+makeExample('template-syntax/ts/app/app.component.html', 'myClick')(format=".")
:marked
  하지만, 지시자 이름은 지시자 클래스의 프로퍼티 이름으로 안 좋은 선택입니다.
  지시자 이름은 프로퍼티가 하는 것을 거의 설명하지 못합니다.
  `myClick` 지시자 이름은 클릭 메시지를 방출하는 프로퍼티의 이름으로 좋지 않은 이름입니다.

  However, the directive name is often a poor choice for the name of a property within the directive class.
  The directive name rarely describes what the property does.
  The `myClick` directive name is not a good name for a property that emits click messages.

  다행히도, 내부적으로 다른 이름을 사용하면서도 관습적인 기대를 충족하는 
  외부용 프로퍼티 이름을 가질 수 있습니다.
  바로 위의 예제에서 사실은 `myClick` *별칭*을 *통해서*
  지시자의 자체 `clicks` 프로퍼티에 바인딩했습니다.

  Fortunately, we can have a public name for the property that meets conventional expectations,
  while using a different name internally.
  In the example immediately above, we are actually binding *through the* `myClick` *alias* to
  the directive's own `clicks` property.

  다음과 같이 input/output 데코레이더에 전달함으로써 프로퍼티 이름의 별칭을 정의할 수 있습니다:

  We can specify the alias for the property name by passing it into the input/output decorator like this:

+makeExample('template-syntax/ts/app/click.directive.ts', 'output-myClick')(format=".")

.l-sub-section
  :marked
    또한 `inputs`와 `outputs` #{_array_ko} 안에 프로퍼티 이름의 별칭을 붙일 수도 있습니다.
    *왼쪽*에 지시자 프로퍼티의 이름을 *오른쪽*에 외부용 별칭을 붙인 
    콜론 구분 (`:`) 문자열을 작성합니다.

    We can also alias property names in the `inputs` and `outputs` #{_array}s.
    We write a colon-delimited (`:`) string with
    the directive property name on the *left* and the public alias on the *right*:
  +makeExample('template-syntax/ts/app/click.directive.ts', 'output-myClick2')(format=".")

<a id="expression-operators"></a>
.l-main-section
:marked
  ## 템플릿 표현식 연산자
  ## Template expression operators

  템플릿 표현식 언어는 특정한 시나리오를 위해 몇가지 특별 연산자를 지원하는 #{_JavaScript} 문법의 서브셋을 사용하고 있습니다. 이 연산자들 중 2개를 다뤄보겠습니다: _pipe_와 _안전 내비게이션 연산자_입니다.

  The template expression language employs a subset of #{_JavaScript} syntax supplemented with a few special operators
  for specific scenarios. We'll cover two of these operators: _pipe_ and _safe navigation operator_.

:marked
  <a id="pipe"></a>
  ### pipe 연산자 ( | )
  ### The pipe operator ( | )
  표현식의 결과를 바인딩에 사용하기 전에 일부 변형이 필요할 수 있습니다. 예를 들어 통화 표시, 대문자 강제전환, 목록 필터 후 정렬을 원할 수 있습니다.

  The result of an expression might require some transformation before we’re ready to use it in a binding.  For example, we might want to display a number as a currency, force text to uppercase, or filter a list and sort it.

  Angular [파이프](./pipes.html)는 이런 작은 변형을 위해 좋은 선택입니다.
  파이프는 입력 값을 받아서 변형된 값을 반환하는 간단한 함수입니다.
  **파이프 연산자 (`|`)**를 사용해 템플릿 표현식에 쉽게 적용할 수 있습니다.

  Angular [pipes](./pipes.html) are a good choice for small transformations such as these.
  Pipes are simple functions that accept an input value and return a transformed value.
  They're easy to apply within template expressions, using the **pipe operator (`|`)**:
+makeExample('template-syntax/ts/app/app.component.html', 'pipes-1')(format=".")
:marked
  파이프 연산자는 왼쪽 표현식의 결과를 오른쪽 파이프 함수로 전달합니다.

  The pipe operator passes the result of an expression on the left to a pipe function on the right.

  여러 파이프를 통해 표현식을 연결할 수도 있습니다:

  We can chain expressions through multiple pipes:
+makeExample('template-syntax/ts/app/app.component.html', 'pipes-2')(format=".")
:marked
  그리고 또한 파이프에 [파라미터 적용](./pipes.html#parameterizing-a-pipe)을 할 수 있습니다:

  And we can also [apply parameters](./pipes.html#parameterizing-a-pipe) to a pipe:
+makeExample('template-syntax/ts/app/app.component.html', 'pipes-3')(format=".")

block json-pipe
  :marked
    `json` 파이프는 바인딩을 디버깅 할 때 특히 유용합니다:

    The `json` pipe is particularly helpful for debugging our bindings:
  +makeExample('template-syntax/ts/app/app.component.html', 'pipes-json')(format=".")
  :marked
    생성된 출력은 다음과 같을 것입니다

    The generated output would look something like this
  code-example(language="json").
    { "firstName": "Hercules", "lastName": "Son of Zeus",
      "birthdate": "1970-02-25T08:00:00.000Z",
      "url": "http://www.imdb.com/title/tt0065832/",
      "rate": 325, "id": 1 }

:marked
  <a id="safe-navigation-operator"></a>
  ### 안전 내비게이션 연산자 ( ?. ) 와 null 프로퍼티 경로
  ### The safe navigation operator ( ?. ) and null property paths

  Angular **안전 내비게이션 연산자 (`?.`)**는 프로퍼티 경로에서 null과 undefined 값을 보호하는 강력하고 편리한 방법입니다.
  다음은 `currentHero`가 null인 경우의 뷰 렌더링 실패에 대한 보호입니다.

  The Angular **safe navigation operator (`?.`)** is a fluent and convenient way to guard against null and undefined values in property paths.
  Here it is, protecting against a view render failure if the `currentHero` is null.
+makeExample('template-syntax/ts/app/app.component.html', 'safe-2')(format=".")

block dart-safe-nav-op
  //- N/A

:marked
  문제를 살펴보고 특별한 해결책을 만들어 봅시다.

  Let’s elaborate on the problem and this particular solution.

  아래와 같은 데이터 연동 `title` 프로퍼티가 null일 경우 어떻게 될까요?

  What happens when the following data bound `title` property is null?
+makeExample('template-syntax/ts/app/app.component.html', 'safe-1')(format=".")
:marked
  뷰는 여전히 렌더링 되지만 표시된 값은 비어있습니다; 오직 "The title is" 만이 보입니다.
  이것은 합리적인 행동입니다. 적어도 앱에 crash가 발생하기 전까지는요.

  The view still renders but the displayed value is blank; we see only "The title is" with nothing after it.
  That is reasonable behavior. At least the app doesn't crash.

  다음 예제처럼 null 히어로의 `firstName`을 표시하는
  템플릿 표현식이 프로퍼티 경로를 포함한 경우를 가정해보겠습니다.

  Suppose the template expression involves a property path, as in this next example
  where we’re displaying the `firstName` of a null hero.

code-example(language="html").
  The null hero's name is {{nullHero.firstName}}

block null-deref-example
  :marked
    JavaScript는 null 참조 에러를 던지므로 Angular는 다음처럼 합니다:

    JavaScript throws a null reference error, and so does Angular:
  code-example(format="nocode").
    TypeError: Cannot read property 'firstName' of null in [null].

:marked
  더 나빠졌군요. *전체 뷰가 사라졌습니다*.

  Worse, the *entire view disappears*.

  `hero` 프로퍼티가 절대로 null이 아니라고 믿는다면 이것도 합리적인 행동이라고 주장할 수 있습니다.
  만약 절대로 null이 아니어야 하지만 여전히 null인 경우,
  반드시 잡아서 고쳐야 하는 프로그래밍 에러를 만들게 된 것입니다.
  예외를 던지는 것이 올바른 처리방법입니다.

  We could claim that this is reasonable behavior if we believed that the `hero` property must never be null.
  If it must never be null and yet it is null,
  we've made a programming error that should be caught and fixed.
  Throwing an exception is the right thing to do.

  반면에 특히 데이터가 결국은 도착할 것이라는 것을 알 경우에,
  프로퍼티 경로의 null 값은 때때로 괜찮을 수 있습니다.

  On the other hand, null values in the property path may be OK from time to time,
  especially when we know the data will arrive eventually.

  데이터를 기다리는 동안, 뷰는 불평 없이 렌더링해야 하고,
  null 프로퍼티 경로는 `title` 프로퍼티가 했던 것처럼 공란으로 보여야 합니다.

  While we wait for data, the view should render without complaint, and
  the null property path should display as blank just as the `title` property does.

  불행히도 우리의 앱은 `currentHero`가 null인 경우 crash가 발생합니다.

  Unfortunately, our app crashes when the `currentHero` is null.

  [NgIf](#ngIf)로 이 문제를 해결할 수 있습니다.

  We could code around that problem with [NgIf](#ngIf).
+makeExample('template-syntax/ts/app/app.component.html', 'safe-4')(format=".")

block safe-op-alt
  :marked
    또는 처음 null을 만나게 되면 표현식에서 탈출하는 것을 알고 있으므로,
    `&&`를 사용한 프로퍼티 경로의 일부를 연결할 수 있습니다,

    Or we could try to chain parts of the property path with `&&`, knowing that the expression bails out
    when it encounters the first null.
  +makeExample('template-syntax/ts/app/app.component.html', 'safe-5')(format=".")

:marked
  이러한 접근법은 장점이 있을 수 있습니다. 특별히 프로퍼티 경로가 긴 경우에.
  `a.b.c.d`와 같은 긴 프로퍼티 패스의 어딘가에서 null 보호를해야 한다고 상상해보세요.

  These approaches have merit but can be cumbersome, especially if the property path is long.
  Imagine guarding against a null somewhere in a long property path such as `a.b.c.d`.

  Angular 안전 내비게이션 연산자 (`?.`)는 프로퍼티 패스에서 null을 보호하는 보다 유창하고 편리한 방법입니다.
  표현식은 처음 null 값을 만나면 탈출합니다.
  공란을 표시하지만 앱은 에러 없이 작동합니다.

  The Angular safe navigation operator (`?.`) is a more fluent and convenient way to guard against nulls in property paths.
  The expression bails out when it hits the first null value.
  The display is blank, but the app keeps rolling without errors.
+makeExample('template-syntax/ts/app/app.component.html', 'safe-6')(format=".")
:marked
  `a?.b?.c?.d`와 같은 긴 프로퍼티 경로에 대해서도 완벽히 동작합니다.

  It works perfectly with long property paths such as `a?.b?.c?.d`.

.l-main-section
:marked
  ## 요약
  ## Summary
  방금 템플릿 구문의 탐험을 마쳤습니다. 이제 우리 자신만의 컴포넌트나 지시자를 만들 때 지식을 써먹을 때가 왔습니다.

  We’ve completed our survey of template syntax. Now it's time to put that knowledge to work as we write our own components and directives.
